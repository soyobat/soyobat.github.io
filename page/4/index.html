<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.soyorin.online","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":10,"width":280,"onmobile":true},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac","show_result":true},"fold":{"enable":false,"height":500},"language":false,"highlight_theme":"night eighties"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
<meta property="og:url" content="https://www.soyorin.online/page/4/index.html">
<meta property="og:site_name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lkl">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="博客">
<meta property="article:tag" content="日常">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.soyorin.online/page/4/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">ε=(´ο｀*)))唉，学Java的这辈子有了</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-友链"><a href="/link/" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lkl"
      src="/images/boqi.jpg">
  <p class="site-author-name" itemprop="name">lkl</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">441</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">71</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/soyobat" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;soyobat" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/10/11/SQL%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/11/SQL%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-title-link" itemprop="url">SQL面试题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-11 01:40:01" itemprop="dateCreated datePublished" datetime="2025-10-11T01:40:01+08:00">2025-10-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-12 21:31:43" itemprop="dateModified" datetime="2025-10-12T21:31:43+08:00">2025-10-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><h3 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> <span class="keyword">TABLE</span>  (XXX)<span class="keyword">VALUE</span>( XX,XX)</span><br><span class="line"><span class="keyword">SELECT</span> XX <span class="keyword">FROM</span> <span class="keyword">TABLE</span> </span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">TABLE</span> <span class="keyword">SET</span> <span class="string">&#x27;XX&#x27;</span> <span class="operator">=</span> XX <span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> </span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="DISTINCT-去重"><a href="#DISTINCT-去重" class="headerlink" title="DISTINCT(去重)"></a>DISTINCT(去重)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name, city <span class="keyword">FROM</span> users;</span><br><span class="line">对(name,city) 所有列去重，即<span class="keyword">sql</span>语句里写的</span><br></pre></td></tr></table></figure>

<h4 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT()"></a>LIMIT()</h4><p>限制返回的行数。<font style="color:rgb(44, 62, 80);">第一个参数为起始行，从 0 开始；第二个参数为返回的总行数</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>返回前<span class="number">5</span>行</span><br><span class="line"><span class="keyword">SELECT</span> city,name <span class="keyword">FROM</span> <span class="keyword">TABLE</span> LIMIT <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> city,name <span class="keyword">FROM</span> <span class="keyword">TABLE</span> LIMIT <span class="number">0</span>,<span class="number">5</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>返回<span class="number">2</span><span class="number">-5</span>行</span><br><span class="line"><span class="keyword">SELECT</span> city,name <span class="keyword">FROM</span> <span class="keyword">TABLE</span> LIMIT <span class="number">2</span>,<span class="number">3</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li>ASC：升序</li>
<li>DESC：降序</li>
</ul>
<p><font style="color:rgb(44, 62, 80);">可以按多个列进行排序，并且为每个列指定不同的排序方式:</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>, col2 <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure>

<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a><font style="color:rgb(44, 62, 80);">过滤</font></h3><table>
<thead>
<tr>
<th>操作符</th>
<th>示例 SQL</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td><code>SELECT * FROM students WHERE city = &#39;北京&#39;;</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td><code>SELECT * FROM students WHERE age &lt; 20;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td><code>SELECT * FROM students WHERE score &gt; 90;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;&gt;</code> 或 <code>!=</code></td>
<td><code>SELECT * FROM students WHERE city &lt;&gt; &#39;北京&#39;;</code></td>
<td>不等于</td>
</tr>
<tr>
<td><code>&lt;=</code> &#x2F; <code>!&gt;</code></td>
<td><code>SELECT * FROM students WHERE age &lt;= 18;</code></td>
<td>小于等于</td>
</tr>
<tr>
<td><code>&gt;=</code> &#x2F; <code>!&lt;</code></td>
<td><code>SELECT * FROM students WHERE score &gt;= 90;</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>BETWEEN</code></td>
<td><code>SELECT * FROM students WHERE score BETWEEN 80 AND 90;</code></td>
<td>在两值之间（包含边界）</td>
</tr>
<tr>
<td><code>IS NULL</code></td>
<td><code>SELECT * FROM students WHERE remark IS NULL;</code></td>
<td>是 NULL</td>
</tr>
<tr>
<td><code>IS NOT NULL</code></td>
<td><code>SELECT * FROM students WHERE remark IS NOT NULL;</code></td>
<td>不是 NULL</td>
</tr>
<tr>
<td><code>AND</code></td>
<td><code>SELECT * FROM students WHERE age &gt; 18 AND score &gt; 80;</code></td>
<td>同时满足两个条件</td>
</tr>
<tr>
<td><code>OR</code></td>
<td><code>SELECT * FROM students WHERE city = &#39;北京&#39; OR city = &#39;上海&#39;;</code></td>
<td>满足任一条件</td>
</tr>
<tr>
<td><code>()</code> 优先级</td>
<td><code>SELECT * FROM students WHERE city=&#39;北京&#39; OR (age &lt; 20 AND score &gt; 80);</code></td>
<td>加括号调整逻辑</td>
</tr>
<tr>
<td><code>IN</code></td>
<td><code>SELECT * FROM students WHERE city IN (&#39;北京&#39;, &#39;上海&#39;);</code></td>
<td>等价于多个 OR</td>
</tr>
<tr>
<td><code>IN (SELECT ...)</code></td>
<td><code>SELECT * FROM students WHERE id IN (SELECT id FROM scores WHERE score&gt;90);</code></td>
<td>从子查询匹配</td>
</tr>
<tr>
<td><code>NOT</code></td>
<td><code>SELECT * FROM students WHERE NOT city = &#39;北京&#39;;</code></td>
<td>否定条件</td>
</tr>
</tbody></table>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a><font style="color:rgb(44, 62, 80);">通配符</font></h3><table>
<thead>
<tr>
<th>通配符</th>
<th>示例 SQL</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>%</code>（&gt;&#x3D;0 个字符）</td>
<td><code>SELECT * FROM students WHERE name LIKE &#39;张%&#39;;</code></td>
<td>匹配所有<strong>以“张”开头</strong>的名字，例如“张三”、“张小明”</td>
</tr>
<tr>
<td><code>%abc%</code></td>
<td><code>SELECT * FROM students WHERE city LIKE &#39;%京%&#39;;</code></td>
<td>匹配<strong>包含“京”</strong> 的城市，例如“北京”、“南京”</td>
</tr>
<tr>
<td><code>_</code>（&#x3D;1 个字符）</td>
<td><code>SELECT * FROM students WHERE name LIKE &#39;_三&#39;;</code></td>
<td>匹配<strong>第二个字是“三”的两个字名字</strong>，如“张三”，但不匹配“王小三”</td>
</tr>
<tr>
<td><code>[ab]</code></td>
<td><code>SELECT * FROM students WHERE name LIKE &#39;[李王]%&#39;;</code> <em>(部分数据库支持，如 SQL Server)</em></td>
<td>匹配<strong>姓李或姓王</strong>的学生</td>
</tr>
<tr>
<td><code>[^ab]</code></td>
<td><code>SELECT * FROM students WHERE name LIKE &#39;[^李王]%&#39;</code>;</td>
<td>匹配<strong>不姓李也不姓王</strong>的学生</td>
</tr>
</tbody></table>
<h3 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a><font style="color:rgb(44, 62, 80);">计算字段</font></h3><p><img src="/images/62e4c62a0bfdcfe030f3d70e4a6a3822.png"></p>
<p><img src="/images/d662a36877079f33f96905905d285e03.png"></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="汇总-重要"><a href="#汇总-重要" class="headerlink" title="汇总(重要)"></a>汇总(重要)</h4><table>
<thead>
<tr>
<th>汇总函数</th>
<th>作用</th>
<th>示例 SQL</th>
<th>示例结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>COUNT(*)</code></td>
<td>计算总行数（包含 NULL）</td>
<td><code>SELECT COUNT(*) FROM students;</code></td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>COUNT(col)</code></td>
<td>统计非 NULL 的个数</td>
<td><code>SELECT COUNT(score) FROM students;</code></td>
<td><code>4</code>（NULL 被忽略）</td>
</tr>
<tr>
<td><code>AVG(col)</code></td>
<td>计算平均值（忽略 NULL）</td>
<td><code>SELECT AVG(score) FROM students;</code></td>
<td><code>(85+90+75+95) / 4 = 86.25</code></td>
</tr>
<tr>
<td><code>SUM(col)</code></td>
<td>求和（忽略 NULL）</td>
<td><code>SELECT SUM(score) FROM students;</code></td>
<td><code>85+90+75+95 = 345</code></td>
</tr>
<tr>
<td><code>MAX(col)</code></td>
<td>最大值</td>
<td><code>SELECT MAX(score) FROM students;</code></td>
<td><code>95</code></td>
</tr>
<tr>
<td><code>MIN(col)</code></td>
<td>最小值</td>
<td><code>SELECT MIN(score) FROM students;</code></td>
<td><code>75</code></td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AVG</span><br><span class="line">SUM</span><br><span class="line">MIN</span><br><span class="line">MAX</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">/</span><span class="operator">/</span>统计全部</span><br><span class="line"><span class="built_in">COUNT</span>(col) <span class="operator">/</span><span class="operator">/</span>统计非空</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/5cdab91ab30be442fa136f396c9e360c.png">、</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACG( <span class="keyword">DISTINCT</span> col) 只会对不同的col做汇总</span><br></pre></td></tr></table></figure>



<h4 id="日期-文本"><a href="#日期-文本" class="headerlink" title="日期&amp;文本"></a>日期&amp;文本</h4><h4 id="数组处理"><a href="#数组处理" class="headerlink" title="数组处理"></a>数组处理</h4><h3 id=""><a href="#" class="headerlink" title=""></a><img src="/images/3f29d31d2fa04422dcafa4714836cc5c.png"></h3><h3 id="分组-重要"><a href="#分组-重要" class="headerlink" title="分组!(重要)"></a>分组!(重要)</h3><p>分组 其实就是把相同的数据值的行放到同一组中</p>
<p>通过我们会要求 返回的是每一组的一个汇总情况</p>
<p><font style="color:rgb(44, 62, 80);">指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。即group by会自动排序</font></p>
<p><strong><font style="color:rgb(44, 62, 80);">WHERE 过滤行，HAVING 过滤分组</font></strong><font style="color:rgb(44, 62, 80);">，行过滤应当先于分组过滤。</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cal,<span class="built_in">SUM</span>(age) <span class="keyword">AS</span> cnt <span class="keyword">FROM</span> <span class="keyword">TABLE</span> </span><br><span class="line">  <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;XX%&#x27;</span> </span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> cal </span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> xxx  </span><br><span class="line">  <span class="keyword">HAVING</span> cnt <span class="operator">&gt;</span> <span class="number">2</span>  </span><br></pre></td></tr></table></figure>

<p><img src="/images/dcab8a9a491b1dbf652b2177d1998373.png"></p>
<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ol>
<li>除了那个汇总字段外，select里出现的字段都应该在 group by中给出</li>
</ol>
<p><img src="/images/4925c107ae827ee914e2f827d07c37a4.png"></p>
<ol start="2">
<li>order by 应该在 group by之后</li>
</ol>
<p><img src="/images/ae7213d6a910a27b61877742f0bff9ae.png"></p>
<ol start="3">
<li><font style="color:rgb(44, 62, 80);">NULL 的行会单独分为一组；</font></li>
<li><font style="color:rgb(44, 62, 80);">MySQL 的group by不支持blog text，其实大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。PS：char()为固定，varchar()为可变</font></li>
</ol>
<font style="color:rgb(44, 62, 80);">  
</font><font style="color:rgb(44, 62, 80);"> </font>

<p><img src="/images/bdcab7981bc69fbf371e58b3449bde43.png"></p>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a><font style="color:rgb(44, 62, 80);">子查询</font></h3><p><strong>！！！子查询只能返回一个字段的数据</strong></p>
<p>可以将子查询的结果作为 WHRER 语句的过滤条件:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> mytable1</span><br><span class="line"><span class="keyword">WHERE</span> col1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> col2</span><br><span class="line">               <span class="keyword">FROM</span> mytable2);</span><br></pre></td></tr></table></figure>

<p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">                   <span class="keyword">FROM</span> Orders</span><br><span class="line">                   <span class="keyword">WHERE</span> Orders.cust_id <span class="operator">=</span> Customers.cust_id)</span><br><span class="line">                   <span class="keyword">AS</span> orders_num</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure>

<h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><h5 id="1️⃣-结构分析"><a href="#1️⃣-结构分析" class="headerlink" title="1️⃣ 结构分析"></a>1️⃣ 结构分析</h5><ol>
<li><strong>外层 SELECT</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT (子查询) AS SecondHighestSalary</span><br></pre></td></tr></table></figure>

<ul>
<li>外层 SELECT 里只有一个表达式：一个 <strong>标量子查询</strong></li>
<li><strong>标量子查询</strong>（scalar subquery）返回 <strong>单个值</strong></li>
<li>即使没有匹配的行，MySQL 也会返回一行，值为 <code>NULL</code></li>
</ul>
<ol>
<li><strong>子查询</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT salary FROM Rank_S WHERE sRank = 2 LIMIT 1</span><br></pre></td></tr></table></figure>

<ul>
<li>查找 <code>sRank = 2</code> 的工资</li>
<li>如果存在多行（同一工资多个员工），<code>LIMIT 1</code> 保证只取 <strong>一行</strong></li>
<li>如果不存在第二高工资（比如表里只有一条记录），子查询 <strong>不返回任何行</strong> → 标量子查询自动返回 <strong>NULL</strong></li>
</ul>
<hr>
<h5 id="2️⃣-为什么保证一行输出"><a href="#2️⃣-为什么保证一行输出" class="headerlink" title="2️⃣ 为什么保证一行输出"></a>2️⃣ 为什么保证一行输出</h5><ul>
<li><strong>外层 SELECT</strong> 不依赖表，只是用标量子查询生成一列</li>
<li>MySQL 规则：</li>
</ul>
<p>标量子查询如果没有返回值 → 结果为 <code>NULL</code></p>
<ul>
<li>外层 SELECT 至少会输出一行（列名 SecondHighestSalary，值为 NULL 或工资值）</li>
</ul>
<hr>
<h5 id="3️⃣-对比普通子查询"><a href="#3️⃣-对比普通子查询" class="headerlink" title="3️⃣ 对比普通子查询"></a>3️⃣ 对比普通子查询</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT salary FROM Rank_S WHERE sRank = 2;</span><br></pre></td></tr></table></figure>

<ul>
<li>直接查询，没找到行 → <strong>返回 0 行</strong></li>
<li>不是标量子查询，外层没有包裹 → 可能没有任何结果行</li>
</ul>
<hr>
<h5 id="4️⃣-总结"><a href="#4️⃣-总结" class="headerlink" title="4️⃣ 总结"></a>4️⃣ 总结</h5><ul>
<li><strong>标量子查询 + 外层 SELECT</strong> → 总是返回一行</li>
<li><strong>LIMIT 1</strong> 保证即使有多行，也只取一行</li>
<li><strong>没有匹配值</strong> → 返回 NULL</li>
<li>✅ 这就是为什么你写法“即使没有第二名，也会返回一行结果”</li>
</ul>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p>
<p>连接可以替换子查询，并且比子查询的效率一般会更快。</p>
<p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表</p>
<p>其实就是根据某个条件把两张表的数据给拼接到一起</p>
<h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>eg：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value <span class="keyword">AS</span> A_value, B.value <span class="keyword">AS</span> B_value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">ON</span> A.key <span class="operator">=</span> B.key;</span><br></pre></td></tr></table></figure>

<p><img src="/images/186b2a331eea95f5332d287b77f4d779.png"></p>
<p><img src="/images/52771237c3e7c0b573906c0dbfaaf580.png"></p>
<p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A, tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">WHERE</span> A.key <span class="operator">=</span> B.key;</span><br></pre></td></tr></table></figure>

<p>在没有条件语句的情况下返回笛卡尔积</p>
<p>PS：内连接；<font style="color:rgb(44, 62, 80);">在没有条件语句的情况下返回笛卡尔积。</font></p>
<h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p>
<p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p>
<p>子查询版本</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> employee</span><br><span class="line"><span class="keyword">WHERE</span> department <span class="operator">=</span> (</span><br><span class="line">      <span class="keyword">SELECT</span> department</span><br><span class="line">      <span class="keyword">FROM</span> employee</span><br><span class="line">      <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;Jim&quot;);</span><br></pre></td></tr></table></figure>

<p>自连接版本</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.name</span><br><span class="line"><span class="keyword">FROM</span> employee <span class="keyword">AS</span> e1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> employee <span class="keyword">AS</span> e2</span><br><span class="line"><span class="keyword">ON</span> e1.department <span class="operator">=</span> e2.department</span><br><span class="line">      <span class="keyword">AND</span> e2.name <span class="operator">=</span> &quot;Jim&quot;;</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ON</span> e1.department <span class="operator">=</span> e2.department</span><br><span class="line">   <span class="keyword">AND</span> e2.name <span class="operator">=</span> &quot;Jim&quot;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>e1.department &#x3D; e2.department：找和某人同部门的员工</p>
<p>e2.name &#x3D; “Jim”：指定 e2 这一行是 “Jim”</p>
<p>换句话说，就是：查找和 Jim 在同一个部门的所有员工。</p>
<h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p>
<p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id <span class="operator">=</span> Orders.cust_id;</span><br></pre></td></tr></table></figure>

<p>customers 表:</p>
<table>
<thead>
<tr>
<th align="center">cust_id</th>
<th align="center">cust_name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">a</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">c</td>
</tr>
</tbody></table>
<p>orders 表:</p>
<table>
<thead>
<tr>
<th align="center">order_id</th>
<th align="center">cust_id</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>结果:</p>
<table>
<thead>
<tr>
<th align="center">cust_id</th>
<th align="center">cust_name</th>
<th align="center">order_id</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">a</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">a</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">c</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">c</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">b</td>
<td align="center">Null</td>
</tr>
</tbody></table>
<h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><p>使用 <strong>UNION</strong> 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p>
<p>每个查询必须包含相同的列、表达式和聚集函数。</p>
<p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p>
<p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p>
<p>总结：</p>
<ul>
<li><strong>合并两个或多个 SELECT 查询的结果</strong></li>
<li>默认会 <strong>去掉重复行</strong></li>
<li>如果想保留重复行，用 <code>UNION ALL</code></li>
<li><strong>要求</strong>：<ol>
<li>每个查询的列数必须相同</li>
<li>对应列的数据类型要兼容</li>
</ol>
</li>
<li><strong>ORDER BY</strong> 只能在最后使用一次</li>
</ul>
<p>可以理解为把查询结果 <strong>“上下拼接在一起”</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> col</span><br><span class="line"><span class="keyword">FROM</span> mytable</span><br><span class="line"><span class="keyword">WHERE</span> col <span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>



<h3 id="MYSQL-8-窗口函数（重要）"><a href="#MYSQL-8-窗口函数（重要）" class="headerlink" title="MYSQL 8 窗口函数（重要）"></a>MYSQL 8 窗口函数（重要）</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shoshana-kong/p/16621254.html">MySQL六种窗口函数用法案例 - 白露~ - 博客园</a></p>
<p>窗口函数（Window Function）是 SQL 中用于<strong>在不分组的前提下对行进行计算</strong>的强大功能，尤其适用于排名、累计求和、移动平均等场景。</p>
<h4 id="常用窗口函数"><a href="#常用窗口函数" class="headerlink" title="常用窗口函数"></a>常用窗口函数</h4><table>
<thead>
<tr>
<th>分类</th>
<th>函数</th>
<th>常见用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>累计&#x2F;聚合</strong></td>
<td><code>SUM()</code>, <code>AVG()</code>, <code>COUNT()</code>, <code>MAX()</code>, <code>MIN()</code></td>
<td>累计和 &#x2F; 移动平均</td>
</tr>
<tr>
<td><strong>排序 &#x2F; 排名</strong></td>
<td><code>ROW_NUMBER()</code>, <code>RANK()</code>, <code>DENSE_RANK()</code></td>
<td>Top N、去重排序</td>
</tr>
<tr>
<td><strong>偏移比较</strong></td>
<td><code>LAG()</code>, <code>LEAD()</code></td>
<td>比较当前行与上一&#x2F;下一行</td>
</tr>
<tr>
<td><strong>统计总数</strong></td>
<td><code>NTILE()</code></td>
<td>分组分位（如四分位）</td>
</tr>
</tbody></table>
<h4 id="窗口函数细则"><a href="#窗口函数细则" class="headerlink" title="窗口函数细则"></a>窗口函数细则</h4><table>
<thead>
<tr>
<th>分类</th>
<th>函数</th>
<th>典型语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>累计 &#x2F; 聚合</strong></td>
<td><code>SUM(expr)</code></td>
<td><code>SUM(weight) OVER (ORDER BY turn)</code></td>
<td>累积求和</td>
</tr>
<tr>
<td></td>
<td><code>AVG(expr)</code></td>
<td><code>AVG(score) OVER (PARTITION BY class)</code></td>
<td>组内平均</td>
</tr>
<tr>
<td></td>
<td><code>COUNT(expr)</code></td>
<td><code>COUNT(*) OVER (ORDER BY date)</code></td>
<td>累计计数</td>
</tr>
<tr>
<td></td>
<td><code>MAX(expr)</code></td>
<td><code>MAX(salary) OVER (PARTITION BY dept)</code></td>
<td>每组最大值</td>
</tr>
<tr>
<td></td>
<td><code>MIN(expr)</code></td>
<td><code>MIN(salary) OVER ()</code></td>
<td>全局最小值</td>
</tr>
<tr>
<td><strong>排序 &#x2F; 排名</strong></td>
<td><code>ROW_NUMBER()</code></td>
<td><code>ROW_NUMBER() OVER (PARTITION BY dept ORDER BY salary DESC)</code></td>
<td>连续排名（无并列）</td>
</tr>
<tr>
<td></td>
<td><code>RANK()</code></td>
<td><code>RANK() OVER (ORDER BY score DESC)</code></td>
<td>有并列，跳号</td>
</tr>
<tr>
<td></td>
<td><code>DENSE_RANK()</code></td>
<td><code>DENSE_RANK() OVER (ORDER BY score DESC)</code></td>
<td>有并列，不跳号</td>
</tr>
<tr>
<td><strong>偏移比较</strong></td>
<td><code>LAG(expr, offset, default)</code></td>
<td><code>LAG(salary, 1, 0) OVER (ORDER BY id)</code></td>
<td>取上一行数据</td>
</tr>
<tr>
<td></td>
<td><code>LEAD(expr, offset, default)</code></td>
<td><code>LEAD(salary) OVER (ORDER BY id)</code></td>
<td>取下一行数据</td>
</tr>
<tr>
<td><strong>分布统计</strong></td>
<td><code>NTILE(n)</code></td>
<td><code>NTILE(4) OVER (ORDER BY score DESC)</code></td>
<td>分成 4 份（四分位）</td>
</tr>
<tr>
<td></td>
<td><code>PERCENT_RANK()</code></td>
<td><code>PERCENT_RANK() OVER (ORDER BY score)</code></td>
<td>百分比排名</td>
</tr>
<tr>
<td></td>
<td><code>CUME_DIST()</code></td>
<td><code>CUME_DIST() OVER (ORDER BY score)</code></td>
<td>累计分布比例</td>
</tr>
<tr>
<td><strong>位置 &#x2F; 首尾</strong></td>
<td><code>FIRST_VALUE(expr)</code></td>
<td><code>FIRST_VALUE(salary) OVER (PARTITION BY dept ORDER BY salary)</code></td>
<td>组内第一个</td>
</tr>
<tr>
<td></td>
<td><code>LAST_VALUE(expr)</code></td>
<td><code>LAST_VALUE(salary) OVER (...)</code></td>
<td>默认要配 frame 子句</td>
</tr>
<tr>
<td></td>
<td><code>NTH_VALUE(expr, n)</code></td>
<td><code>NTH_VALUE(score, 2) OVER (...)</code></td>
<td>取第 n 个</td>
</tr>
</tbody></table>
<h4 id="OVER语法"><a href="#OVER语法" class="headerlink" title="OVER语法"></a>OVER语法</h4><p>OVER，<code>OVER</code> 里只能出现 <code>PARTITION BY</code> 和 <code>ORDER BY</code></p>
<table>
<thead>
<tr>
<th>写法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>OVER()</code></td>
<td>不分组也不排序，整个表算</td>
</tr>
<tr>
<td><code>OVER(PARTITION BY ...)</code></td>
<td>在每个组内计算</td>
</tr>
<tr>
<td><code>OVER(ORDER BY ...)</code></td>
<td>按顺序逐行累积</td>
</tr>
<tr>
<td><code>OVER(PARTITION BY ... ORDER BY ...)</code></td>
<td>分组后再排序计算</td>
</tr>
</tbody></table>
<h2 id="大厂真题"><a href="#大厂真题" class="headerlink" title="大厂真题"></a>大厂真题</h2><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><h4 id="2021年11月每天的人均浏览文章时长-牛客题霸-牛客网"><a href="#2021年11月每天的人均浏览文章时长-牛客题霸-牛客网" class="headerlink" title="2021年11月每天的人均浏览文章时长_牛客题霸_牛客网"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/share/jump/1715904441760249304550">2021年11月每天的人均浏览文章时长_牛客题霸_牛客网</a></h4><p>统计2021年11月每天的人均浏览文章时长（秒数），结果保留1位小数，并按时长由短到长排序</p>
<p>分析： </p>
<p>:::info</p>
<h1 id="sum-out-time-in-time-count-distinct-uid-as-avg-time-where-月份-group-by-day-order-by-avg-time"><a href="#sum-out-time-in-time-count-distinct-uid-as-avg-time-where-月份-group-by-day-order-by-avg-time" class="headerlink" title="sum(out_time - in_time) &#x2F; count(distinct uid)   as avg_time where 月份 group by day order by avg_time"></a>sum(out_time - in_time) &#x2F; count(distinct uid)   as avg_time where 月份 group by day order by avg_time</h1><p>函数使用：</p>
<p>人均：sum(out_time - in_time) &#x2F; count(distinct uid)</p>
<p>每天的：group by day</p>
<p>2021年11月：where date_time() &#x3D; “”</p>
<p>保留1位小数：Round(  value,1)</p>
<p>:::</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="SQL-50"><a href="#SQL-50" class="headerlink" title="SQL 50"></a>SQL 50</h2><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/10/11/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/%E6%97%A0%E6%A0%87%E9%A2%98%E6%96%87%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/11/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/%E6%97%A0%E6%A0%87%E9%A2%98%E6%96%87%E6%A1%A3/" class="post-title-link" itemprop="url">无标题文档</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-11 01:27:54" itemprop="dateCreated datePublished" datetime="2025-10-11T01:27:54+08:00">2025-10-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%89%8B%E5%86%99%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">手写系列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/10/09/Redis/Redisson/Redisson%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/09/Redis/Redisson/Redisson%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">Redisson延迟队列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-10-09 23:50:54 / 修改时间：23:51:11" itemprop="dateCreated datePublished" datetime="2025-10-09T23:50:54+08:00">2025-10-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/Redisson/" itemprop="url" rel="index"><span itemprop="name">Redisson</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/10/09/Redis/Redisson/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/09/Redis/Redisson/" class="post-title-link" itemprop="url">Redisson</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-10-09 23:50:45 / 修改时间：23:50:50" itemprop="dateCreated datePublished" datetime="2025-10-09T23:50:45+08:00">2025-10-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/10/09/ai%20%E5%BA%94%E7%94%A8%E7%9B%B8%E5%85%B3/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93%E4%B8%8EJSON%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E7%9F%9B%E7%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/09/ai%20%E5%BA%94%E7%94%A8%E7%9B%B8%E5%85%B3/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93%E4%B8%8EJSON%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E7%9F%9B%E7%9B%BE/" class="post-title-link" itemprop="url">用户体验：如何解决流式传输与JSON结构化的矛盾</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-10-09 09:23:57 / 修改时间：09:52:25" itemprop="dateCreated datePublished" datetime="2025-10-09T09:23:57+08:00">2025-10-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ai-%E5%BA%94%E7%94%A8%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">ai 应用相关</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><font style="color:rgb(51, 51, 51);">在前面的内容里，我们讨论了一些让大模型高质量输出内容的方法。其中让大模型输出 JSON 格式的数据，是一个非常有效且方便的方法。但是，当我们要进一步改善用户体验，希望通过流式传输减少等待时间时，就会发现 JSON 数据格式本身存在一个问题。对于从事前端行业的你来说，JSON 应该并不陌生，它是一种封闭的数据结构，通常以左花括号“{”开头，右花括号“}”结尾。封闭的数据结构，意味着一般情况下，前端对 JSON 的解析必须等待 JSON 数据全部传输完成，否则会因为 JSON 数据不完整而导致解析报错。这就导致一个问题，即使我们在前端用流式获取 JSON 数据，我们也得等待 JSON 完成后才能解析数据并更新 UI，这就让原本流式数据快速响应的特性失效了。那么有没有办法解决这个问题呢？JSON 的流式解析办法是有的。为了解决这个问题，有些人主张规范大模型的输出，比如采取 NDJSON（Newline-Delimited JSON）的方式，要求大模型输出的内容分为多行，每一行是一个独立的 JSON。但是这么做对大模型的输出进行了限制，不够灵活，而且很可能会影响大模型推理的准确性，有点得不偿失。另外一些人则使用 </font><strong><font style="color:rgb(51, 51, 51);">JSONStream</font></strong><font style="color:rgb(51, 51, 51);"> 库，根据大模型输出的 JSON 配合 JSONStream 使用，这样能一定程度上解决问题，但是也不够通用，必须要事先针对大模型输出的特定结构进行处理，而且只能在 Server 端进行处理，没法直接在前端使用。</font></p>
<p><font style="color:rgb(51, 51, 51);"></font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/travel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TravelController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChatClient chatClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TravelController</span><span class="params">(ChatClient chatClient)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.chatClient = chatClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/stream&quot;, produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span></span><br><span class="line">    <span class="keyword">public</span> Flux&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">streamScenicSpots</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">prompt</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        请依次介绍中国的5个著名景点。</span></span><br><span class="line"><span class="string">        每个景点单独输出一个JSON对象，不要合并。</span></span><br><span class="line"><span class="string">        格式如下：</span></span><br><span class="line"><span class="string">        &#123;&quot;name&quot;: &quot;景点名&quot;, &quot;desc&quot;: &quot;简介&quot;&#125;</span></span><br><span class="line"><span class="string">        每个景点之间用字符串 &lt;END&gt; 分隔。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chatClient.prompt()</span><br><span class="line">                .user(prompt)</span><br><span class="line">                .stream()</span><br><span class="line">                .flatMap(chunk -&gt; &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> chunk.getOutput().getContent();</span><br><span class="line">                    buffer.append(text);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 按 &lt;END&gt; 分割</span></span><br><span class="line">                    List&lt;Map&lt;String, Object&gt;&gt; ready = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    <span class="type">int</span> idx;</span><br><span class="line">                    <span class="keyword">while</span> ((idx = buffer.indexOf(<span class="string">&quot;&lt;END&gt;&quot;</span>)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">jsonChunk</span> <span class="operator">=</span> buffer.substring(<span class="number">0</span>, idx).trim();</span><br><span class="line">                        buffer.delete(<span class="number">0</span>, idx + <span class="string">&quot;&lt;END&gt;&quot;</span>.length());</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Map&lt;String, Object&gt; json = <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().readValue(jsonChunk, Map.class);</span><br><span class="line">                            ready.add(json);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            <span class="comment">// 不完整的JSON先跳过</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 返回所有完整JSON块</span></span><br><span class="line">                    <span class="keyword">return</span> Flux.fromIterable(ready);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/09/28/%E5%85%AB%E8%82%A1%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/28/%E5%85%AB%E8%82%A1%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">八股面经</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-28 21:33:57" itemprop="dateCreated datePublished" datetime="2025-09-28T21:33:57+08:00">2025-09-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-13 22:39:46" itemprop="dateModified" datetime="2025-10-13T22:39:46+08:00">2025-10-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h2><h3 id="小红书日常二面"><a href="#小红书日常二面" class="headerlink" title="小红书日常二面"></a>小红书日常二面</h3><p>HTTP传输最小的一个字节，是多大的数据包?</p>
<p>:::info<br>“在 HTTP 层，理论上可以只发送 1 个字节的数据，例如一个非常小的响应体。<br>但是 HTTP 是基于 TCP 的，而 TCP 又基于 IP，所以在网络上传输时，会被封装成 TCP&#x2F;IP 数据包。</p>
<ul>
<li>TCP 报文段最小有 20 字节 TCP 头 + 20 字节 IP 头，总共至少 40 字节。</li>
<li>如果是在以太网环境下，以太网帧最小长度是 64 字节，低于这个长度会自动填充。</li>
</ul>
<p>所以即便 HTTP 只发送 1 个字节，网络层实际传输的最小数据包大约是 <strong>64 字节</strong>。<br>总结来说，HTTP 层最小可以 1 字节，但网络上实际传输受到协议栈和以太网最小帧限制。”</p>
<p>假设你在浏览器访问网站，发送了一个 HTTP GET 请求，只有 1 个字节的响应体（比如返回 “A”）：</p>
<ol>
<li><strong>HTTP 层</strong>：响应内容是 “A”，只有 1 字节</li>
<li><strong>TCP&#x2F;IP 层</strong>：加上 TCP 头 20B + IP 头 20B → 40B</li>
<li><strong>以太网层</strong>：以太网帧最小 64B，不够 64B → 自动填充</li>
<li><strong>结果</strong>：即使 HTTP 只传 1 字节，实际在网线上传输的也是 64 字节的帧</li>
</ol>
<p>所以“以太网帧”就是你电脑和路由器之间实际在网线里流动的数据单元。</p>
<p>:::</p>
<p>HTTPS的原理?和HTTP区别?</p>
<p>:::info<br>HTTPS 的原理，其实就是在应用层和传输层之间加了一层 <strong>TLS&#x2F;SSL</strong>，用于对 HTTP 传输的数据进行加密。</p>
<p>它涉及几个关键点：</p>
<ol>
<li><strong>握手过程</strong><ul>
<li>首先客户端发起请求，同时发送一个随机数、支持的密码套件，以及椭圆曲线相关参数（基点等）。</li>
<li>客户端本地生成一个临时私钥，并计算出对应的公钥发送给服务端。</li>
</ul>
</li>
<li><strong>服务端响应</strong><ul>
<li>服务端收到请求后，生成一个随机数，选择密码套件，也生成一个临时私钥。</li>
<li>每次请求都会生成新的临时私钥，以保证前向安全性（即每次会话的密钥都是唯一的，不使用固定私钥）。</li>
</ul>
</li>
<li><strong>密钥协商</strong><ul>
<li>双方通过椭圆曲线的基点、各自的私钥以及对方发送的公钥，计算出本次会话的对称加密密钥。</li>
<li>这个密钥之后用于加密 HTTP 传输的数据。</li>
</ul>
</li>
<li><strong>握手确认</strong><ul>
<li>第一次握手：客户端发起请求</li>
<li>第二次握手：服务端返回公钥和选择的密码套件</li>
<li>第三次握手：客户端确认并生成会话密钥</li>
<li>第四次握手（可选）：服务端确认信息完整</li>
<li>通过这几次握手，双方最终确认一个安全的会话密钥，用于本次 HTTPS 会话</li>
</ul>
</li>
</ol>
<h3 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h3><ul>
<li>HTTP：TCP 三次握手后即可直接发送请求，传输的是明文数据。</li>
<li>HTTPS：除了 TCP 三次握手，还要经过 TLS 握手（大约 3~4 次），建立安全的加密会话，所以传输速度略慢，但安全性高。</li>
</ul>
<p>:::</p>
<p>传输是对称加密还是非对称加密?</p>
<p>:::info</p>
<p>生成密钥后的通信就是 对称加密了</p>
<p>生成密钥前就是 使用的是非对称加密。对称用的密钥就是</p>
<p>:::</p>
<h3 id="淘天暑期"><a href="#淘天暑期" class="headerlink" title="淘天暑期"></a>淘天暑期</h3><p>网络里面交换机和路由器区别?</p>
<p>常见网络协议?</p>
<p>介绍下HTTP?</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="美团暑期二面"><a href="#美团暑期二面" class="headerlink" title="美团暑期二面"></a>美团暑期二面</h3><p>操作系统里的LRU算法?</p>
<p>:::info<br>面试官你是想问我们在那个页面置换里面的那个吗。</p>
<p>其实是说，在我们因为我们的操作系统它的内存是有限的么，它就是说如果我们内存到了一定的紧张程度的话，它就是需要我们通过一个算法把这个用不到的页面置换出去，操作系统底层用的是LRU算法，但它可以选择不同算法，但是不同的内核版本，它应该有不同的一个实现然后它就是说把最久没使用的页面给淘汰出去。</p>
<p>这个的话，它其实是可能会有一个问题，就是说我们如果一次性加载了多个页面进来后，它可能会把以前的一个老页面给顶出去，它可能会有就是其实我们所谓的一个缓存污染这么一个问题，所以说，操作系统它底层对我们这个LRU是进行了一个改进的就是说，它通过我们一个其实跟mysql的Bufferpool算法有点类似，就是分old 和 yong区分，然后他们大概是3,7分。然后它淘汰的时候，它也是优先投入小的区域，然后直到你这个小数据被访问，它才会放到我们的一个old区，就是避免一次性读取大量数据，然后把一些老的反而真正常用数据给顶掉。所以说，我觉得这是他对LRU改进最大的一个地方，也是比较核心的一个点么</p>
<p>:::</p>
<p>a.LRU的思想是什么?</p>
<p>:::info<br>它就是出于一种局部性原理，就操作系统他其实有这么一个概念，一种是时间局部性，比如说你在一定时间内访问了某个数据，未来的一段时间内，你对这个数据的访问频率可能会更大，然后还有一个就是空间局部性，就是说你访问了所谓的一个数据，然后接下来，你访问这个数据的概率也是比较大的。所以说，它就是说优先淘汰掉我们以前比较久远的一个数据吧，我觉得是这样子淘汰的一个思想嗯。</p>
<p>:::</p>
<p>用Java常见数据结构如何设计一个LRU?操作时间复杂度?线程安全性?</p>
<p>:::info<br>额如果用现成的话，我就会直接用jdk collection里自带的一个LInkedHashMap，其实说白了底层就是用HashMap+双向链表这样子。要详细说一下，然后Map就是作为我们的一个Key查询，因为我们缓存的根本目的还是希望通过一个key来实现O1复杂的查询么。所以说，我们肯定是得通过一个Map来进行一个</p>
<p>存储我们的缓存数据，然后LRU，比较好的数据结构就是双向链表么，它的目的就是说把访问的数据放到我们的一个头部么，然后把尾部的数据，就是我们不经常访问的数据，然后一旦我们的数据size大于我们的limit，就把这个尾部的数据delete掉么</p>
<p>Map&lt;String,Node&gt;</p>
<p>Node1 &lt;&#x3D;&gt;  Node2</p>
<p>插入的话是Map插一次，然后插到头结点，都是O1。</p>
<p>查找的话一个就是从Map里面查，容纳后就是从双向链表里找到节点，然后把它，因为它只涉及到指针的移动，所以也是O1</p>
<p>线程安全这一块的话，我觉得得看你怎么实现吧，如果你要简单粗暴的话，就是一把synchronized或者对象锁直接对增删改查进行加锁，这时候就是只允许一个线程进行增删改查。它这样就肯定是线程安全的么，但就是锁的粒度太大了，我们可以尝试把它放小，比如读写锁，只有写操作才加锁，读的话就没报要加锁了，但就是后面的链表指针的移动这些我觉得还是得加了。就具体看我们要怎么实现</p>
<p>:::</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="美团暑期二面-1"><a href="#美团暑期二面-1" class="headerlink" title="美团暑期二面"></a>美团暑期二面</h3><p>h.IO耗时长，吞吐上不来，cpu又吃不满，如何优化吞吐量?</p>
<p>7.Go和Java最大的区别?</p>
<p>a.协程和线程区别?</p>
<p>b.JDK也有类似协程的东西，你知道吗?8.如何理解“全异步链路”的?(网关介绍里的)a.做过这个事，那为什么不用异步解决刚刚说的优化吞吐的事?</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><h3 id="字节暑期"><a href="#字节暑期" class="headerlink" title="字节暑期"></a>字节暑期</h3><p>ZSet做排行榜，需要展示前1000人的榜单，1001-1500展示实际排名，1500以后展示1000+，如何处理 Bigkey?</p>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>13.自己举例一个SQL，说说MySQL是如何查数据的?</p>
<p>14.表中有status和isDelete字段，where status&#x3D;’已完成and isDelete &#x3D;’N’超时，但数据量不大，只有一两百万条，可能是什么原因?如何解决?</p>
<p>:::info<br>举个例子，在数据库索引信息里有一个字段，比如叫 <em>Cardinality</em>，意思就是这个索引列里面有多少个<strong>不同的值</strong>，也就是索引的<strong>区分度</strong>。</p>
<p>一般来说，这个值越接近表里的总行数，说明每一行的数据都不一样，区分度就越高，索引效果就越好。</p>
<p>但如果某个字段是状态字段，比如只有 <code>success</code> 和 <code>fail</code> 两种值，各占一半，那不管你怎么建索引，这个索引的区分度都很低，因为查询 <code>status=&#39;success&#39;</code> 仍然会匹配表里 50% 的数据。</p>
<p>这种情况下数据库优化器可能会觉得“既然要扫一半，我干脆直接全表扫描就好了”，所以这个索引就不一定会被真正用上。</p>
<p>解决方案：</p>
<p> “虽然表只有一两百万条数据，但 <code>status</code> 和 <code>isDelete</code> 是低区分度字段，优化器认为即使用索引过滤也要扫描大部分行，所以退化为全表扫描导致超时。解决方式是建立<strong>联合索引</strong>提升选择性或者使用<strong>覆盖索引</strong>，必要时强制优化器使用索引。”  </p>
<p><img src="/images/3e600cff6d5abc60cd7edd4ad53e028e.png"></p>
<p>解决方案：分页出来的数据order by limit  + 内存里根据主键查询 数据 过滤出想要的数据</p>
<p>:::</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/09/26/kafka/%E6%BA%90%E7%A0%81/producor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/26/kafka/%E6%BA%90%E7%A0%81/producor/" class="post-title-link" itemprop="url">producor</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-09-26 20:04:08 / 修改时间：20:40:41" itemprop="dateCreated datePublished" datetime="2025-09-26T20:04:08+08:00">2025-09-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/kafka/" itemprop="url" rel="index"><span itemprop="name">kafka</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/kafka/%E6%BA%90%E7%A0%81/" itemprop="url" rel="index"><span itemprop="name">源码</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/09/25/Codetop%E5%88%B7%E9%A2%98/%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/25/Codetop%E5%88%B7%E9%A2%98/%E6%A0%91/" class="post-title-link" itemprop="url">树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-25 19:46:30" itemprop="dateCreated datePublished" datetime="2025-09-25T19:46:30+08:00">2025-09-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-28 08:20:38" itemprop="dateModified" datetime="2025-10-28T08:20:38+08:00">2025-10-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Codetop%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Codetop刷题</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>二叉树问题思考角度就是站到ROOT节点，思考我要让<strong>左右节点返回给我什么信息</strong>。然后<strong>思考我有了这个信息后要干什么</strong></p>
<h2 id="路径总和-III-12"><a href="#路径总和-III-12" class="headerlink" title="路径总和 III[12]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/"><font style="color:rgb(10, 132, 255);">路径总和 III</font></a>[12]</h2><p>数组情况：和为k的子数组</p>
<p>思路：</p>
<ol>
<li>暴力，以每个节点为起点出发，然后直接遍历到终点。两层for循环</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//暴力</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">targetSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> _targetSum)</span> &#123;</span><br><span class="line">        <span class="comment">//暴力搜索，类似于我们 普通前缀和的 两层for循环</span></span><br><span class="line">        targetSum = (<span class="type">long</span>)_targetSum;</span><br><span class="line">        t1(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t1</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//起点</span></span><br><span class="line">        traverse(root, <span class="number">0</span>);</span><br><span class="line">        t1(root.left);</span><br><span class="line">        t1(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root,<span class="type">long</span> curSum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curSum+=root.val;</span><br><span class="line">        <span class="keyword">if</span>(curSum == targetSum) res++;</span><br><span class="line">        traverse(root.left, curSum);</span><br><span class="line">        traverse(root.right, curSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>前缀和+ 两数之和</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//暴力</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">targetSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//只针对单一个数</span></span><br><span class="line">    <span class="comment">//k：前缀和 v：相同前缀和的个数</span></span><br><span class="line">    Map&lt;Long, Integer&gt; preSumCounter = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> _targetSum)</span> &#123;</span><br><span class="line">        <span class="comment">//前缀和 + 两数之和</span></span><br><span class="line">        targetSum = (<span class="type">long</span>) _targetSum;</span><br><span class="line">        preSumCounter.put(<span class="number">0L</span>, <span class="number">1</span>); <span class="comment">// 前缀和为0的次数为1</span></span><br><span class="line">        traverse(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">long</span> curSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curSum += root.val;</span><br><span class="line">        <span class="comment">// preSum - xx = targetSum</span></span><br><span class="line">        <span class="comment">// preSum - targetSum = xx</span></span><br><span class="line">        <span class="comment">//即在map里找是否有 树为 presum + (-targetSum)</span></span><br><span class="line">        res += preSumCounter.getOrDefault(curSum + (-targetSum), <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//更新前缀和</span></span><br><span class="line">        preSumCounter.put(curSum, preSumCounter.getOrDefault(curSum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        traverse(root.left, curSum);</span><br><span class="line">        traverse(root.right, curSum);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//回退</span></span><br><span class="line">        preSumCounter.put(curSum, preSumCounter.get(curSum) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树中的最大路径和-173"><a href="#二叉树中的最大路径和-173" class="headerlink" title="二叉树中的最大路径和[173]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">二叉树中的最大路径和</a>[<font style="color:rgb(96, 98, 102);background-color:rgb(237, 245, 254);">173</font>]</h2><p>思路</p>
<ol>
<li>站在ROOT节点思考左右节点要返回给我什么信息？我希望左子节点返回给我左子树的最大路径和。右节点类似</li>
<li>思考有了这个信息要干什么。无非就是求出最大路径和<br>四种情况<br>leftSum + cur.val</li>
</ol>
<p>rightSum + cur.val</p>
<p>cur.val</p>
<p>cur.val + leftSum + rightSum</p>
<p><img src="/images/12d127c55af1ae5ec9cccb56f88e5740.jpeg" alt="画板"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSum</span> <span class="operator">=</span> dfs(cur.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightSum</span> <span class="operator">=</span> dfs(cur.right);</span><br><span class="line">        <span class="comment">//子树的返回</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> Math.max(cur.val, Math.max(leftSum,rightSum) + cur.val);</span><br><span class="line">        <span class="comment">//最终结果</span></span><br><span class="line">        res = Math.max(res, Math.max(ret, cur.val + leftSum + rightSum));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的最近公共祖先-251"><a href="#二叉树的最近公共祖先-251" class="headerlink" title="二叉树的最近公共祖先[251]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree"><font style="color:rgb(64, 158, 255);">二叉树的最近公共祖先</font></a>[<font style="color:rgb(96, 98, 102);background-color:rgb(245, 247, 250);">251</font>]</h2><p>思路：</p>
<p>法一：DFS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//法一 dfs</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root, p, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">dfs</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> dfs(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> dfs(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span> (left == right)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//p,q都没找到</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>法二：Map存子节点-&gt;父节点，然后转换成相交链表问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//k：子节点 v：父节点</span></span><br><span class="line">    Map&lt;TreeNode, TreeNode&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        dfs(root, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//q节点的祖先 集合</span></span><br><span class="line">        Set&lt;TreeNode&gt; qZX = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="literal">null</span>) &#123;</span><br><span class="line">            qZX.add(q);</span><br><span class="line">            q = map.get(q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//相交节点</span></span><br><span class="line">            <span class="keyword">if</span> (qZX.contains(p)) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = map.get(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode cur, TreeNode par)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(cur, par);</span><br><span class="line">        dfs(cur.left, cur);</span><br><span class="line">        dfs(cur.right, cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度都是O( N )</strong></p>
<h2 id="对称二叉树-91"><a href="#对称二叉树-91" class="headerlink" title="对称二叉树[91]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree"><font style="color:rgb(64, 158, 255);">对称二叉树</font></a>[91]</h2><p>思路：</p>
<p>1. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(root==<span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//调用递归函数，比较左节点，右节点</span></span><br><span class="line">		<span class="keyword">return</span> dfs(root.left,root.right);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line">		<span class="comment">//递归的终止条件是两个节点都为空</span></span><br><span class="line">		<span class="comment">//或者两个节点中有一个为空</span></span><br><span class="line">		<span class="comment">//或者两个节点的值不相等</span></span><br><span class="line">		<span class="keyword">if</span>(left==<span class="literal">null</span> &amp;&amp; right==<span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(left==<span class="literal">null</span> || right==<span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(left.val!=right.val) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//再递归的比较 左节点的左孩子 和 右节点的右孩子</span></span><br><span class="line">		<span class="comment">//以及比较  左节点的右孩子 和 右节点的左孩子</span></span><br><span class="line">		<span class="keyword">return</span> dfs(left.left,right.right) &amp;&amp; dfs(left.right,right.left);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：王尼玛</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/symmetric-tree/solutions/46560/dong-hua-yan-shi-101-dui-cheng-er-cha-shu-by-user7/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<h2 id="翻转二叉树-67"><a href="#翻转二叉树-67" class="headerlink" title="翻转二叉树[67]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree"><font style="color:rgb(64, 158, 255);">翻转二叉树</font></a>[<font style="color:rgb(96, 98, 102);background-color:rgb(236, 245, 255);">67</font>]</h2><p>思路：</p>
<ol>
<li>翻转左右子节点就好，然后就交给递归函数了</li>
</ol>
<p><img src="/images/f3a8ad90d065a8f3737ce6573d6cc827.webp"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> dfs(root.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> dfs(root.right);</span><br><span class="line">        <span class="comment">//在根节点 交换左右子节点即可</span></span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的最大深度-87"><a href="#二叉树的最大深度-87" class="headerlink" title="二叉树的最大深度[87]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree"><font style="color:rgb(64, 158, 255);">二叉树的最大深度</font></a>[87]</h2><p>思路（DFS）：</p>
<ol>
<li>if(root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) 结果更新时</li>
</ol>
<p>思路（BFS）:</p>
<ol>
<li>层序遍历，每过一层 depth++</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//int cnt = 0;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            dfs(root,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> cnt)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            res = Math.max(res,cnt);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left,cnt + <span class="number">1</span>);</span><br><span class="line">        dfs(root.right,cnt + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BFS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>)</span><br><span class="line">            q.add(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.remove();</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.add(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.add(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的直径-79"><a href="#二叉树的直径-79" class="headerlink" title="二叉树的直径[79]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree"><font style="color:rgb(64, 158, 255);">二叉树的直径</font></a>[79]</h2><p>思路</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//也是站在当前根节点 思考 左右子节点要给我返回什么</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lM</span> <span class="operator">=</span> dfs(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rM</span> <span class="operator">=</span> dfs(root.right);</span><br><span class="line">        res = Math.max(lM + rM, res);</span><br><span class="line">        <span class="comment">// 这个 1 是指Cur节点返回给上一级的时候，要把cur节点 加上去</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(lM, rM) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="验证二叉搜索树-79"><a href="#验证二叉搜索树-79" class="headerlink" title="验证二叉搜索树[79]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree"><font style="color:rgb(64, 158, 255);">验证二叉搜索树</font></a>[<font style="color:rgb(96, 98, 102);background-color:rgb(237, 245, 254);">79</font>]</h2><p>思路：</p>
<ol>
<li>二叉搜索树 中序遍历 为 单调递增数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        f1(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list.get(i) &lt;= list.get(i - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二叉搜索树 中序遍历 为 单调递增数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f1(root.left);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        f1(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的序列化与反序列化-57"><a href="#二叉树的序列化与反序列化-57" class="headerlink" title="二叉树的序列化与反序列化[57]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">二叉树的序列化与反序列化</a>[57]</h2><p>思路：</p>
<ol>
<li>序列化容易，就是前序遍历，转成字符串，或者层序遍历</li>
<li>反序列化比较难，一种是bfs，一种是dfs</li>
<li>就是你序列化以BFS，你反序列化就是要BFS。DFS同样</li>
<li>题目其实就是给你root，序列化成字符串，然后再根据字符串反序列为树</li>
</ol>
<p>DFS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">serRes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        f1(root);</span><br><span class="line">        <span class="keyword">return</span> serRes.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            serRes.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> serRes.append(root.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        f1(root.left);</span><br><span class="line">        f1(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        String []datas = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> builder(datas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构建树</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">builder</span><span class="params">(String[] data)</span>&#123;</span><br><span class="line">        <span class="comment">//看示例1 即 从上到下，从右倒左遍历</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">curV</span> <span class="operator">=</span> data[index];</span><br><span class="line">        index++;</span><br><span class="line">        <span class="comment">//当前节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">curNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(curV.equals(<span class="string">&quot;null&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> curNode;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">curVN</span> <span class="operator">=</span> Integer.parseInt(curV);</span><br><span class="line">            curNode = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(curVN);</span><br><span class="line">            <span class="comment">//左右子节点 交给子树去构造，相信递归</span></span><br><span class="line">            curNode.left = builder(data);</span><br><span class="line">            curNode.right = builder(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> curNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec deser = new Codec();</span></span><br><span class="line"><span class="comment">// TreeNode ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure>

<p>BFS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">serRes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">                serRes.append(cur.val).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                q.add(cur.left);</span><br><span class="line">                q.add(cur.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serRes.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serRes.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line"></span><br><span class="line">        String[] datas = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder(datas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建树</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">builder</span><span class="params">(String[] data)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data.length == <span class="number">0</span> || data[<span class="number">0</span>].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(data[<span class="number">0</span>]));</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.add(res);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">curNode</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="keyword">if</span> (!data[index].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                curNode.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(data[index]));</span><br><span class="line">                q.add(curNode.left);</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (!data[index].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                curNode.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(data[index]));</span><br><span class="line">                q.add(curNode.right);</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec deser = new Codec();</span></span><br><span class="line"><span class="comment">// TreeNode ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure>

<h2 id="二叉树展开为链表-43"><a href="#二叉树展开为链表-43" class="headerlink" title="二叉树展开为链表[43]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">二叉树展开为链表</a>[<font style="color:rgb(96, 98, 102);background-color:rgb(241, 246, 252);">43</font>]</h2><p>思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode pre=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pre.right=root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//提前保存一下即可，防止丢失子树</span></span><br><span class="line">        TreeNode tmp=root.right;</span><br><span class="line">        pre=root;</span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(tmp);</span><br><span class="line">        root.left=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="不同的二叉搜索树-31"><a href="#不同的二叉搜索树-31" class="headerlink" title="不同的二叉搜索树[31]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">不同的二叉搜索树</a>[<font style="color:rgb(96, 98, 102);background-color:rgb(236, 245, 255);">31</font>]</h2><p>背诵题</p>
<p>思路：</p>
<ol>
<li>找规律，先找出 比如 1个节点（n&#x3D;1），2,….的时候，这时候有多少种二叉搜索树</li>
<li>然后再找 n和n-1的关系，即递归公式</li>
</ol>
<p>明确它的一个dp数组含义了，即 第i个节点 有多少种二叉搜索树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//1: 1</span></span><br><span class="line">        <span class="comment">//2: 2</span></span><br><span class="line">        <span class="comment">//3: 5</span></span><br><span class="line">        <span class="comment">//dp数组含义：n = i时有多少种二叉搜索树</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">////如果整数1 ~ n中的 k 作为根节点值，则 1 ~ k-1 会去构建左子树，k+1 ~ n 会去构建右子树。!!!</span></span><br><span class="line">        <span class="keyword">if</span>( n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> []dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= n;i++)&#123;</span><br><span class="line">            <span class="comment">//在 i 范围内，当前节点val = k </span></span><br><span class="line">            <span class="comment">//如果整数1 ~ i中的 k 作为根节点值，则 1 ~ k-1 会去构建左子树，k+1 ~ i 会去构建右子树。!!!</span></span><br><span class="line">            <span class="comment">//此时 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;k &lt;= i - <span class="number">1</span>;k++)&#123;</span><br><span class="line">                <span class="comment">//左 和 右 组合</span></span><br><span class="line">                <span class="comment">//为什么组合这里是乘法？</span></span><br><span class="line">                dp[i] += dp[k] * dp[i - k - <span class="number">1</span>]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1️⃣-为什么是-乘法？"><a href="#1️⃣-为什么是-乘法？" class="headerlink" title="1️⃣ 为什么是 乘法？"></a>1️⃣ 为什么是 <strong>乘法</strong>？</h3><p>我们考虑：</p>
<p>如果整数 <code>1 ~ i</code> 中选 <code>k</code> 作为根节点，<br>左子树可以用 <code>1 ~ k-1</code> 构建，右子树可以用 <code>k+1 ~ i</code> 构建。</p>
<p>假设：</p>
<ul>
<li>左子树可以构建 <code>L = dp[k]</code> 种不同的 BST</li>
<li>右子树可以构建 <code>R = dp[i - k - 1]</code> 种不同的 BST</li>
</ul>
<p><strong>总的 BST 数量 &#x3D; 左子树方案数 × 右子树方案数</strong></p>
<p>为什么是乘法？<br>因为<strong>每一种左子树</strong>都可以和<strong>每一种右子树</strong>组合成一个新的 BST。<br>这是经典的排列组合思想：<code>左 * 右</code>。</p>
<p><strong>比如小明有4个苹果，小红有5个香蕉。他们组合是多少，那肯定是4*5</strong></p>
<p>举个小例子：</p>
<ul>
<li><code>k=2</code>，左子树用 <code>1</code> 构建 → 1 种方案</li>
<li>右子树用 <code>3,4</code> 构建 → 2 种方案</li>
</ul>
<p>总的 BST 数 &#x3D; <code>1 * 2 = 2</code> 种。</p>
<hr>
<h3 id="2️⃣-dp-k-和-dp-i-k-1-分别是左子树和右子树"><a href="#2️⃣-dp-k-和-dp-i-k-1-分别是左子树和右子树" class="headerlink" title="2️⃣ dp[k] 和 dp[i - k - 1] 分别是左子树和右子树"></a>2️⃣ dp[k] 和 dp[i - k - 1] 分别是左子树和右子树</h3><ul>
<li><code>dp[k]</code> → <strong>左子树</strong>的方案数<br>因为左子树包含 <code>k</code> 左边的 <code>k</code> 个节点（<code>1 ~ k</code>），所以 dp[k]</li>
<li><code>dp[i - k - 1]</code> → <strong>右子树</strong>的方案数<br>因为右子树包含剩下的 <code>i - k - 1</code> 个节点（<code>k+1 ~ i</code>），所以 dp[i - k - 1]</li>
</ul>
<p>⚠️ 注意下标关系：</p>
<ul>
<li>i &#x3D; 当前节点总数</li>
<li>k &#x3D; 左子树节点数（或根节点下标？在你的循环中，<code>k</code>是左子树节点数）</li>
<li>右子树节点数 &#x3D; i - k - 1</li>
</ul>
<h2 id="打家劫舍-III-19"><a href="#打家劫舍-III-19" class="headerlink" title="打家劫舍 III[19]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii"><font style="color:rgb(64, 158, 255);">打家劫舍 III</font></a>[<font style="color:rgb(96, 98, 102);background-color:rgb(236, 245, 255);">19</font>]</h2><h2 id="路径总和-III"><a href="#路径总和-III" class="headerlink" title="路径总和 III[]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii"><font style="color:rgb(64, 158, 255);">路径总和 III</font></a>[]</h2><h2 id="实现-Trie-前缀树-34"><a href="#实现-Trie-前缀树-34" class="headerlink" title="实现 Trie (前缀树)[34]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/">实现 Trie (前缀树)</a>[<font style="color:rgb(96, 98, 102);background-color:rgb(242, 246, 252);">34</font>]</h2><p>思路：</p>
<ol>
<li>构造26叉树</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node[] son = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">end</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">//无路可走？ new 出来</span></span><br><span class="line">            <span class="keyword">if</span> (cur.son[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                cur.son[index] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.son[index];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.end = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(word) == <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> find(prefix) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.son[index] == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            cur = cur.son[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2为找到了 1为找到前缀</span></span><br><span class="line">        <span class="keyword">return</span> cur.end ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="把二叉搜索树转换为累加树-4"><a href="#把二叉搜索树转换为累加树-4" class="headerlink" title="把二叉搜索树转换为累加树[4]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">把二叉搜索树转换为累加树</a>[<font style="color:rgb(96, 98, 102);background-color:rgb(238, 246, 254);">4</font>]</h2><p>思路：</p>
<ol>
<li>利用二叉搜索树的特性，中序遍历为 有序数组</li>
<li>然后算出中序遍历后的数组的每个的元素的后缀和</li>
<li>然后再次中序遍历更改 树节点的val</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; l = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="comment">//System.out.println(l);</span></span><br><span class="line">        <span class="comment">//每个节点 node 的新值  等于  原树中大于或等于 node.val 的值之和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; l.size(); i++)&#123;</span><br><span class="line">            sum += l.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; l.size(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> l.get(i);</span><br><span class="line">            l.set(i, sum - preSum);</span><br><span class="line">            preSum += temp;</span><br><span class="line">        &#125;</span><br><span class="line">        generate(root);</span><br><span class="line">        <span class="comment">//System.out.println(l);</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        traverse(root.left);</span><br><span class="line">        l.add(root.val);</span><br><span class="line">        traverse(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        generate(root.left);</span><br><span class="line">        root.val = l.get(index); </span><br><span class="line">        index++;</span><br><span class="line">        generate(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树[]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees"><font style="color:rgb(64, 158, 255);">合并二叉树</font></a>[]</h2><p>思路</p>
<ol>
<li>前序遍历，但这样是错误，在merge时，root1 &#x3D; root2，改变的不是引用！</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        dfs(root1, root2);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root1,TreeNode root2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root1 == <span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            root1 = root2;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root1 != <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root1 != <span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            root1.val += root2.val;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root1.left,root2.left);</span><br><span class="line">        dfs(root1.right,root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(root1, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回节点</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(TreeNode root1, TreeNode root2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 != <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">        <span class="keyword">if</span>(root1 != <span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>) res.val = root1.val + root2.val; </span><br><span class="line">        res.left = build(root1.left, root2.left);</span><br><span class="line">        res.right = build(root1.right, root2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/09/25/Codetop%E5%88%B7%E9%A2%98/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/25/Codetop%E5%88%B7%E9%A2%98/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" class="post-title-link" itemprop="url">滑动窗口</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-09-25 14:23:21 / 修改时间：19:07:24" itemprop="dateCreated datePublished" datetime="2025-09-25T14:23:21+08:00">2025-09-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Codetop%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Codetop刷题</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="无重复字符的最长子串-1005"><a href="#无重复字符的最长子串-1005" class="headerlink" title="无重复字符的最长子串[1005]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters"><font style="color:rgb(64, 158, 255);">无重复字符的最长子串</font></a>[<font style="color:rgb(96, 98, 102);background-color:rgb(244, 247, 251);">1005</font>]</h2><h2 id="滑动窗口最大值-134"><a href="#滑动窗口最大值-134" class="headerlink" title="滑动窗口最大值[134]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum"><font style="color:rgb(64, 158, 255);">滑动窗口最大值</font></a>[<font style="color:rgb(96, 98, 102);background-color:rgb(244, 247, 250);">134</font>]</h2><p>思路：</p>
<ol>
<li>固定窗口</li>
<li>单调递减队列（队列头到队列尾）来维护区间最大值</li>
</ol>
<p>这是一个降本增笑的故事：</p>
<p>如果新员工比老员工强（或者一样强），把老员工裁掉。（元素进入窗口）</p>
<p>如果老员工 35 岁了，也裁掉。（元素离开窗口）</p>
<p>裁员后，资历最老（最左边）（队列头）的人就是最强的员工了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(); <span class="comment">// 单调队列，存下标，保持递减</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; r &lt; nums.length; r++) &#123;</span><br><span class="line">            <span class="comment">// 移除队尾比当前元素小的下标</span></span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; nums[dq.peekLast()] &lt; nums[r]) &#123;</span><br><span class="line">                dq.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.offerLast(r);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当窗口长度 &gt;= k</span></span><br><span class="line">            <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 队头就是最大值</span></span><br><span class="line">            res.add(nums[dq.peekFirst()]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移除队头已经滑出窗口的下标</span></span><br><span class="line">            <span class="keyword">if</span> (!dq.isEmpty() &amp;&amp; dq.peekFirst() == l) &#123;</span><br><span class="line">                dq.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小覆盖子串-114"><a href="#最小覆盖子串-114" class="headerlink" title="最小覆盖子串[114]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring"><font style="color:rgb(64, 158, 255);">最小覆盖子串</font></a>[<font style="color:rgb(96, 98, 102);background-color:rgb(237, 245, 254);">114</font>]</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/09/25/Codetop%E5%88%B7%E9%A2%98/%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/25/Codetop%E5%88%B7%E9%A2%98/%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">排序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-25 14:22:04" itemprop="dateCreated datePublished" datetime="2025-09-25T14:22:04+08:00">2025-09-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-14 20:23:23" itemprop="dateModified" datetime="2025-10-14T20:23:23+08:00">2025-10-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Codetop%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Codetop刷题</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="排序数组-321"><a href="#排序数组-321" class="headerlink" title="排序数组[321]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array">排序数组</a>[<font style="color:rgb(96, 98, 102);background-color:rgb(242, 246, 252);">321</font>]</h2><p>思路</p>
<p><img src="/images/083f92f2300f13669876d188ae0d57d3.png"></p>
<p>快排，堆，计数，归并</p>
<ol>
<li>快排</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> []nums, <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> <span class="variable">indexX</span> <span class="operator">=</span> partition(nums, l, r);</span><br><span class="line">       <span class="comment">//l....indexX</span></span><br><span class="line">       sort(nums, l ,indexX - <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//indeX...r</span></span><br><span class="line">       sort(nums, indexX + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> []nums, <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + random.nextInt( r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        swap(nums, l, i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">curL</span> <span class="operator">=</span> l + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curR</span> <span class="operator">=</span> r;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(curL &lt;= curR &amp;&amp; nums[curL] &lt; x)&#123;</span><br><span class="line">                curL++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(curL &lt;= curR &amp;&amp; nums[curR] &gt; x)&#123;</span><br><span class="line">                curR--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curL &gt;= curR) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            swap(nums, curL, curR);</span><br><span class="line">            curL++;</span><br><span class="line">            curR--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, l, curR);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> curR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> []nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>题目特殊性，时间复杂度为O(N)的解法，采用计数排序</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/solutions/179210/dang-wo-tan-pai-xu-shi-wo-zai-tan-xie-shi-yao-by-s/">https://leetcode.cn/problems/sort-an-array/solutions/179210/dang-wo-tan-pai-xu-shi-wo-zai-tan-xie-shi-yao-by-s/</a><br><img src="/images/915fa73acbf49f5d75669d66b7feebbe.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">50001</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> -<span class="number">50001</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] counter = <span class="keyword">new</span> <span class="title class_">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            counter[num - min]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//index 为 数组值 value为 数组值的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> min; i &lt;= max; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> counter[i - min];</span><br><span class="line">            <span class="comment">// cnt &gt; 0说明存在</span></span><br><span class="line">            <span class="keyword">while</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[index] = i;</span><br><span class="line">                cnt--;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>归并排序</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//归并排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> []nums, <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        sort(nums, l, mid);</span><br><span class="line">        sort(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">//合并 [l...mid] [mid + 1....r]</span></span><br><span class="line">        merge(nums, l, mid, mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> []nums, <span class="type">int</span> s1, <span class="type">int</span> e1, <span class="type">int</span> s2, <span class="type">int</span> e2)</span>&#123;</span><br><span class="line">        <span class="comment">// [s1...e1] [s1 ... e2]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s1;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s2;</span><br><span class="line">        <span class="comment">// [2,4] [1,5]</span></span><br><span class="line">        <span class="comment">// [1,2,4,]</span></span><br><span class="line">        <span class="type">int</span> []temp = <span class="keyword">new</span> <span class="title class_">int</span>[e2 - s1 + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temp.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= e1 || j &lt;= e2)&#123;</span><br><span class="line">            <span class="keyword">while</span>( i &gt; e1 &amp;&amp; j &lt;= e2)&#123;</span><br><span class="line">                temp[k] = nums[j];</span><br><span class="line">                k++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; e2 &amp;&amp; i &lt;= e1)&#123;</span><br><span class="line">                temp[k] = nums[i];</span><br><span class="line">                k++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//谁小谁先移动</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                temp[k] = nums[j];</span><br><span class="line">                k++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k] = nums[i];</span><br><span class="line">                k++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(temp, <span class="number">0</span>, nums, s1, temp.length);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字典序排数-13"><a href="#字典序排数-13" class="headerlink" title="字典序排数[13]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lexicographical-numbers/"><font style="color:rgb(10, 132, 255);">字典序排数</font></a>[13]</h2><p>思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">lexicalOrder</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//256</span></span><br><span class="line">        <span class="comment">// 1 10 100 101...109 11</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res.add(j);</span><br><span class="line">            <span class="keyword">if</span> (j * <span class="number">10</span> &lt;= n) &#123;</span><br><span class="line">                j = j * <span class="number">10</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 1 10 100 101...109 11 or  1,2 </span></span><br><span class="line">                <span class="comment">// 109 -&gt; 11 ,2 -&gt; 3</span></span><br><span class="line">                <span class="keyword">while</span> (j % <span class="number">10</span> == <span class="number">9</span> || j + <span class="number">1</span> &gt; n) &#123;</span><br><span class="line">                    j = j / <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序链表-133"><a href="#排序链表-133" class="headerlink" title="排序链表[133]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list"><font style="color:rgb(64, 158, 255);">排序链表</font></a>[133]</h2><p>思路：</p>
<ol>
<li>归并排序<br>head….tail-&gt; head….mid mid…tail</li>
</ol>
<p>不断分，然后并起来</p>
<p>归：对链表进行分割，直到每个链表只有一个 元素</p>
<p>并：对链表进行升序合并</p>
<p>链表取中点（快慢指针），并切割</p>
<ol start="2">
<li>快排（容易超时）</li>
</ol>
<p>图（归并）</p>
<p><img src="/images/6ad2b2f301a27c27e6eec5242a92745b.jpeg" alt="画板"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sort(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从中间分开</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">divide</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并排序</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sort</span><span class="params">(ListNode head1)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="literal">null</span> || head1.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拆成两部分，并返回后部门的头结点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> divide(head1);</span><br><span class="line">        <span class="comment">//mid(4→2→1→3)   ---&gt; 分成两部分</span></span><br><span class="line">        <span class="comment">//head1: 4 → 2 → null</span></span><br><span class="line">        <span class="comment">//head2: 1 → 3 → null</span></span><br><span class="line">        head1 = sort(head1);</span><br><span class="line"></span><br><span class="line">        head2 = sort(head2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(head1, head2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两链表合并，要有序</span></span><br><span class="line">    <span class="comment">// head1 .... </span></span><br><span class="line">    <span class="comment">// head2 ....</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> res;</span><br><span class="line">        <span class="keyword">while</span> (head1 != <span class="literal">null</span> || head2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">                cur.next = head1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head1 == <span class="literal">null</span>) &#123;</span><br><span class="line">                cur.next = head2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head1.val &gt; head2.val) &#123;</span><br><span class="line">                cur.next = head2;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = head1;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：NlogN 空间复杂度：logN</p>
<h2 id="合并K个排序链表-221"><a href="#合并K个排序链表-221" class="headerlink" title="合并K个排序链表[221]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists"><font style="color:rgb(64, 158, 255);">合并K个排序链表</font></a>[<font style="color:rgb(96, 98, 102);background-color:rgb(237, 245, 255);">221</font>]</h2><p>思路：</p>
<ol>
<li>归并排序</li>
<li>堆（可能需要手写）排序</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//最小堆，堆顶为最小值</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a.val - b.val);</span><br><span class="line">        <span class="comment">//先将最小的放进来</span></span><br><span class="line">        <span class="keyword">for</span>(ListNode head: lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            pq.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> dummyHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">minNode</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">            res.next = minNode;</span><br><span class="line">            res = res.next;</span><br><span class="line">            <span class="keyword">if</span>(minNode.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                pq.add(minNode.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><font style="color:rgb(255, 255, 255);background-color:rgb(15, 15, 15);">时间复杂度：</font><font style="color:rgba(239, 241, 246, 0.75);background-color:rgb(15, 15, 15);">O</font><font style="color:rgba(239, 241, 246, 0.75);background-color:rgb(15, 15, 15);">(</font><em><font style="color:rgba(239, 241, 246, 0.75);background-color:rgb(15, 15, 15);">L</font></em><font style="color:rgba(239, 241, 246, 0.75);background-color:rgb(15, 15, 15);">lo</font><font style="color:rgba(239, 241, 246, 0.75);background-color:rgb(15, 15, 15);">g</font><em><font style="color:rgba(239, 241, 246, 0.75);background-color:rgb(15, 15, 15);">m</font></em><font style="color:rgba(239, 241, 246, 0.75);background-color:rgb(15, 15, 15);">)</font><font style="color:rgb(255, 255, 255);background-color:rgb(15, 15, 15);">，其中</font><font style="color:rgb(255, 255, 255);background-color:rgb(15, 15, 15);"> </font><em><font style="color:rgba(239, 241, 246, 0.75);background-color:rgb(15, 15, 15);">m</font></em><font style="color:rgb(255, 255, 255);background-color:rgb(15, 15, 15);"> </font><font style="color:rgb(255, 255, 255);background-color:rgb(15, 15, 15);">为</font><font style="color:rgb(255, 255, 255);background-color:rgb(15, 15, 15);"> </font><em><font style="color:rgba(239, 241, 246, 0.75);background-color:rgb(15, 15, 15);">lists</font></em><font style="color:rgb(255, 255, 255);background-color:rgb(15, 15, 15);"> </font><font style="color:rgb(255, 255, 255);background-color:rgb(15, 15, 15);">的长度，</font><em><font style="color:rgba(239, 241, 246, 0.75);background-color:rgb(15, 15, 15);">L</font></em><font style="color:rgb(255, 255, 255);background-color:rgb(15, 15, 15);"> </font><font style="color:rgb(255, 255, 255);background-color:rgb(15, 15, 15);">为所有链表的长度之和。</font></li>
</ul>
<h2 id="数组中的第K个最大元素-550"><a href="#数组中的第K个最大元素-550" class="headerlink" title="数组中的第K个最大元素[550]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a>[<font style="color:rgb(96, 98, 102);background-color:rgb(237, 245, 255);">550</font>]</h2><p>题目：</p>
<ol>
<li>要求时间复杂度为O(N)</li>
</ol>
<p>思路：</p>
<ol>
<li>维护size &#x3D;&#x3D; k的最小堆（但不符合题意）时间复杂度：nums.length log(k)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i: nums)&#123;</span><br><span class="line">            pq.add(i);</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; k)&#123;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(pq);</span></span><br><span class="line">        <span class="keyword">return</span> pq.isEmpty()?-<span class="number">1</span>:pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>快速选择</li>
</ol>
<p>思路：</p>
<ol>
<li>构建partition函数，里面干的就是 数组随机取一个 x，然后划分 <x x >x</li>
<li>如何划分！？<br>1、小技巧，先将 l 和 x交换，方便后面处理</li>
</ol>
<p>2、curL–&gt; …. &lt;—curR，while把curL和curR推进到需要交换的位置，然后swap，交换后，重复这个过程<br>		外层while(true) 内层while 推进curL,curR。若curR&lt;&#x3D;curL退出全部循环</p>
<p>3、将x放回正确位置，—&gt; swap(l,curR)</p>
<ol start="3">
<li>经过划分我们可以得到<x x >x。那么这个时候判断x的index 和 targetIndex( n - k)的位置</li>
<li>若 index &#x3D; targertIdex 就是找到答案了，直接返回。若index &gt; targetIndex 则说明targetIndex在右边，那么这个时候让r &#x3D; index缩小范围，反之，让l &#x3D; index</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//选一个基准 元素 x</span></span><br><span class="line">        <span class="comment">// &lt;x.... x... &gt;x</span></span><br><span class="line">        <span class="comment">//如果 i = n - k ,那么 res = i</span></span><br><span class="line">        <span class="comment">//如果 i &gt; n - k, 那么res在左侧，我们在其中寻找，重复第一步</span></span><br><span class="line">        <span class="comment">//如果 i &lt; n - k, 那么res在右侧，我们在其中寻找，重复第一步</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; k) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetIndex</span> <span class="operator">=</span> n - k;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">resIndex</span> <span class="operator">=</span> partition(nums, l, r);</span><br><span class="line">            <span class="keyword">if</span>(resIndex == targetIndex)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[resIndex];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//redIndex 在 targetIndex右边 说明 targetIndex的数在 l...resIndex 中</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(resIndex &gt; targetIndex)&#123;</span><br><span class="line">                r = resIndex - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                l = resIndex + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> []nums, <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + rand.nextInt(r - l + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="comment">//System.out.println(x); </span></span><br><span class="line">        <span class="comment">//交换左边界元素 和 x，方便后面实现</span></span><br><span class="line">        swap(nums, l, i);</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(nums));</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curL</span> <span class="operator">=</span> l + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curR</span> <span class="operator">=</span> r;</span><br><span class="line">        <span class="comment">//处理示意图： (&lt; x) curL-&gt; (没处理的元素) &lt;-curR ( &gt; x)</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(curL &lt;= curR &amp;&amp; nums[curL] &lt; x)&#123;</span><br><span class="line">                curL++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//经过上面的while循环此时 nums[curL] &gt;= x</span></span><br><span class="line">            <span class="keyword">while</span>(curL &lt;= curR &amp;&amp; nums[curR] &gt; x)&#123;</span><br><span class="line">                curR--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//经过上面的while循环此时 nums[curL] &lt;= x</span></span><br><span class="line">            <span class="keyword">if</span>(curL &gt;= curR) <span class="keyword">break</span>;</span><br><span class="line">            swap(nums, curL, curR);</span><br><span class="line">            curR--;</span><br><span class="line">            curL++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(nums)); </span></span><br><span class="line">        swap(nums, l, curR);</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(nums)); </span></span><br><span class="line">        <span class="keyword">return</span> curR;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 交换 nums[i] 与 nums[j]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="颜色分类-41"><a href="#颜色分类-41" class="headerlink" title="颜色分类[41]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/">颜色分类</a>[<font style="color:rgb(96, 98, 102);background-color:rgb(237, 245, 254);">41</font>]</h2><p>思路：</p>
<ol>
<li>三路快排（三指针法）。0…zero i two…n -1<br><img src="/images/8f18a02ad80b076771dd046f32474cda.png"></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        </span><br><span class="line">         </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">zero</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">two</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//[0 zero] 全为 0 </span></span><br><span class="line">        <span class="comment">//[zero i] 全为 1</span></span><br><span class="line">        <span class="comment">//[two, n-1] 全为 2</span></span><br><span class="line">        <span class="comment">// 0 1 2</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= two)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums, i, zero);</span><br><span class="line">                zero++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                swap(nums, i, two);</span><br><span class="line">                two--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者计数排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] counter = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i: nums)&#123;</span><br><span class="line">            counter[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> counter[i];</span><br><span class="line">            <span class="keyword">while</span>(cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[index] = i;</span><br><span class="line">                index++;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/45/">45</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2019 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">lkl</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/soyobat" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
