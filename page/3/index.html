<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.soyorin.online","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.26.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":10,"width":280,"onmobile":true},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":true,"style":"mac","show_result":true},"fold":{"enable":false,"height":500},"language":false,"highlight_theme":"night eighties"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
<meta property="og:url" content="https://www.soyorin.online/page/3/index.html">
<meta property="og:site_name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lkl">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="学习">
<meta property="article:tag" content="博客">
<meta property="article:tag" content="日常">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://www.soyorin.online/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">ε=(´ο｀*)))唉，学Java的这辈子有了</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-友链"><a href="/link/" rel="section"><i class="fas fa-link fa-fw"></i>友链</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lkl"
      src="/images/boqi.jpg">
  <p class="site-author-name" itemprop="name">lkl</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">441</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">71</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/soyobat" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;soyobat" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/10/20/MySQL/limit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/20/MySQL/limit/" class="post-title-link" itemprop="url">limit</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-10-20 21:35:02 / 修改时间：21:55:17" itemprop="dateCreated datePublished" datetime="2025-10-20T21:35:02+08:00">2025-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>SELECT * FROM users ORDER BY id LIMIT 10, 20; </p>
<p>从偏移量为10开始，返回20行记录，即第11到第30行记录 </p>
<p>如果是limit 20000000 10，那会把前两千万条数据查出来，然后丢弃，然后从第20000001行开始返回10行，性能极低，这就是深度分页问题 </p>
<p>深度分页优化： </p>
<p>可以把每次查询到的最大id记录下来，下次从这个id开始继续查： </p>
<p>SELECT * FROM users WHERE id &gt; last_max_id ORDER BY id LIMIT 10; </p>
<p>但这种方案不能往回查，只能一页一页往后查，且查询过程中不能有新增 </p>
<p>id不能重复，不然就会陷入死循环，比如一页的10条，ID全是12，last_max_id也为12，那么下一页的查询还是&gt;&#x3D; 12</p>
<p>覆盖索引 + 子查询： </p>
<p>SELECT * FROM users WHERE id &gt; (SELECT id FROM users ORDER BY id LIMIT 20000000, 1) ORDER BY id LIMIT 10; </p>
<p>子查询在主键索引上查询，不需要回表，得到第20000001的id，然后主查询根据id进行范围查询 </p>
<p>使用ES，ES也有深分页问题，但影响比MySQL小点 </p>
<p>【【IT老齐074】从76237到753毫秒,海量数据大页码MySQL查询该如何优化？】<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1PL411g7Vj?vd_source=cae07b1dce3e6abe67fcf72c43031ede">https://www.bilibili.com/video/BV1PL411g7Vj?vd_source&#x3D;cae07b1dce3e6abe67fcf72c43031ede</a></p>
<p>产品上解决问题：</p>
<p><img src="/images/12f730a5ad043373d4315dcf13be21d6.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/10/20/MySQL/%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/20/MySQL/%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">架构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-10-20 13:24:24 / 修改时间：21:34:26" itemprop="dateCreated datePublished" datetime="2025-10-20T13:24:24+08:00">2025-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>旧表拆分为分库分表过程： </p>
<ol>
<li>双写读老阶段：通过中间件，对write sql同时进行两次转发，也就是双写，保持新数据一致，同时开始历史数据拷贝。本阶段建议施行一周； </li>
<li>双写双读阶段：采用灰度策略，一部分流量读老表，一部分流量读新表，读新表的部分在一开始，还可以同时多读一次老表数据，进行比对检查，观察无误后，随着时间慢慢切量到新表。本阶段建议施行至少两周； </li>
<li>双写读新阶段：此时基本已经稳定，可以只读新表，为了安全保证，建议还是多双写一段时间，防止有问题遗漏。本阶段建议周期一个月； </li>
<li>写新读新阶段：此时已经完成了分表的迁移，老表数据可以做个冷备</li>
</ol>
<p>MySQL主从复制 </p>
<p>MySQL的主从是由从节点<strong>主动去读</strong>主节点的binlog，然后保存到自己的中转日志处Relay Log，并在本地执行。此时不管Slave是否已接收binlog, Slave写relay log失败、重新执行SQL语句失败等异常情况并不会被Master感知，所以数据一致性无法得到有效保障 </p>
<p><img src="/images/1ac7e99f5e79e5f98e8241b6d66b9f1f.png"></p>
<p>MySQL 5.5版本提供了半同步复制模式：Master在提交事务前，会等待Slave接收binlog, 当<strong>至少有一个Slave</strong>确认接收了binlog后，Master才提交事务。具体来说，<strong>Slave在收到binlog并将其写入relay log后，会向Master发送ACK响应</strong>；Master在收到ACK响应后， 认为响应发送方Slave已经在relay log中保存了事务，这时才进行事务的提交 </p>
<p>Master会因为向过多的Slave复制数据而压力倍增，这个问题被称为“<strong>复制风暴</strong>”。所 以实际的<strong>主从模式架构可能是一些Slave向Slave复制数据</strong>，以减轻Master的复制压力，</p>
<p>一主多从，从挂从</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/10/20/MySQL/%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/20/MySQL/%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">后台线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-10-20 10:01:13 / 修改时间：22:46:44" itemprop="dateCreated datePublished" datetime="2025-10-20T10:01:13+08:00">2025-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li>Master Thread： 非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性。包括脏页的刷新、刷盘redo、合并插入缓冲和undo页的回收等 </li>
<li>IO Thread： InnoDB中大量使用了异步IO，IO Thread主要负责这些IO请求的回调处理。分有write、read、insert buffer和log Thread </li>
<li>Purge Thread：InnoDB 1.1加入，回收undo页，减轻Master Thread负担 </li>
<li>Page Cleaner Thread：InnoDB 1.2.x版本中加入，刷新脏页，减轻Master Thread负担</li>
</ol>
<p>InnoDB 1.0.x 版本之前的Master Thread： </p>
<p>由多个循环（loop）组成：主循环（loop）、后台循环（background loop）、刷新循环（flush loop）、暂停循环（suspend loop） </p>
<ul>
<li>主循环（loop）：</li>
</ul>
<p>每秒的操作：日志缓冲刷新到磁盘（总是，即使这个事务还没提交） </p>
<p> 合并插入缓冲（如果前一秒内的IO次数小于5次才执行这个操作） </p>
<p> 至多刷新100个脏页到磁盘（脏页比例超过innodb_max_dirty_pages_pct（默认90，代表90%）的话执行这个操作） </p>
<p> 切换到background loop循环（如果当前没有用户活动的话） </p>
<p>每十秒的操作：刷新100个脏页到磁盘（如果过去十秒内的IO次数少于200次的话） </p>
<p> 合并至多5个插入缓冲（总是） </p>
<p> 将日志缓冲刷新到磁盘（总是） </p>
<p> 删除无用的undo（总是，最多尝试回收20个） </p>
<p> 刷新100个或者10个脏页到磁盘（总是，如果脏页比例超过70%，刷100个，否则刷10个） </p>
<ul>
<li>后台循环（background loop）：</li>
</ul>
<p>删除无用的undo（总是） </p>
<p>合并20个插入缓冲（总是） </p>
<p>切换到flush loop循环（如果当前空闲的话） </p>
<p>跳回到主循环（如果当前不空闲的话） </p>
<ul>
<li>刷新循环（flush loop）：</li>
</ul>
<p>不断刷新100个脏页直到脏页比例小于innodb_max_dirty_pages_pct </p>
<p>切换到suspend loop循环 </p>
<ul>
<li>暂停循环（suspend loop）：</li>
</ul>
<p>将Master Thread挂起，等待事件发生，有事件发生切换到loop主循环 </p>
<p>InnoDB1.2.x版本之前的Master Thread： </p>
<ol>
<li>InnoDB1.0.x之前的Master Thread做了许多硬编码，把参数写死了，InnoDB1.0.x开始提供了参数innodb_io_capacity，默认值200 <ul>
<li>在合并插入缓冲时，合并的数量为innodb_io_capacity的5% </li>
<li>刷新脏页时，刷新脏页的数量为innodb_io_capacity</li>
</ul>
</li>
<li>innodb_max_dirty_pages_pct默认值从90调为75 </li>
<li>新增参数innodb_adaptive_flushing（自适应地刷新，默认为on，打开），通过redo log的产生速度决定最合适的刷新脏页数量，当脏页比例小于innodb_max_dirty_pages_pct时也会刷新一定量的脏页 </li>
<li>新增参数innodb_purge_batch_size，默认值20，每次回收undo页的数量由该值决定 </li>
<li>当数据库压力大时，Master Thread的主循环并不总是等待一秒，会加快速度</li>
</ol>
<p>InnoDB1.2.x版本的Master Thread： </p>
<p>刷新脏页的操作分离到单独的Page Cleaner Thread线程 </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/10/17/ai%20%E5%BA%94%E7%94%A8%E7%9B%B8%E5%85%B3/%E7%BB%93%E5%90%88deepWiki%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/17/ai%20%E5%BA%94%E7%94%A8%E7%9B%B8%E5%85%B3/%E7%BB%93%E5%90%88deepWiki%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81/" class="post-title-link" itemprop="url">结合deepWiki阅读源码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-10-17 02:18:53 / 修改时间：02:19:31" itemprop="dateCreated datePublished" datetime="2025-10-17T02:18:53+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/ai-%E5%BA%94%E7%94%A8%E7%9B%B8%E5%85%B3/" itemprop="url" rel="index"><span itemprop="name">ai 应用相关</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/images/ddfcdc00d0e5c639c71dcd99cda246a1.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/10/16/Codetop%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/16/Codetop%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">链表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-16 21:06:19" itemprop="dateCreated datePublished" datetime="2025-10-16T21:06:19+08:00">2025-10-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 14:45:21" itemprop="dateModified" datetime="2025-10-17T14:45:21+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Codetop%E5%88%B7%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">Codetop刷题</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="合并两个有序链表-306"><a href="#合并两个有序链表-306" class="headerlink" title="合并两个有序链表[306]"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists"><font style="color:rgb(64, 158, 255);">合并两个有序链表</font></a>[<font style="color:rgb(96, 98, 102);background-color:rgb(245, 247, 250);">306</font>]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/10/14/MySQL/%E5%BC%95%E6%93%8E/InnoDB/InnoDB%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/14/MySQL/%E5%BC%95%E6%93%8E/InnoDB/InnoDB%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7/" class="post-title-link" itemprop="url">InnoDB关键特性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-14 22:39:47" itemprop="dateCreated datePublished" datetime="2025-10-14T22:39:47+08:00">2025-10-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-20 09:59:06" itemprop="dateModified" datetime="2025-10-20T09:59:06+08:00">2025-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/%E5%BC%95%E6%93%8E/" itemprop="url" rel="index"><span itemprop="name">引擎</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/%E5%BC%95%E6%93%8E/InnoDB/" itemprop="url" rel="index"><span itemprop="name">InnoDB</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a><font style="color:#DF2A3F;">插入缓冲</font></h2><p>当要插入数据时，对于唯一索引来说：</p>
<p>若索引页在内存的话，则往内存插入。若不在，则先把对应的索引页加载到内存，然后判断是否重，然后插入</p>
<p>对于非唯一索引而言，对应的索引页在内存的话，同上，然后写redo。</p>
<p>而对于不在的情况，则是将“插入xxx数据”记录到insert buffer（其实insert buffer是一个 b+树）里，同时将</p>
<p>写 insert buffer这个行为写一条日志到redo log（此时的redo就不是传统意义上的物理日志），<strong>整个操作没</strong></p>
<p><strong>有磁盘IO</strong></p>
<hr>
<p>change buffer是InnoDB1.0x对insert buffer的升级，扩展了delete buffer（标记删除），purge buffer（真</p>
<p>正删除）。change buffer不仅可以缓冲插入，更改和删除也可以。change buffer位于buffer pool中，大小</p>
<p>由innodb_change_buffer_max_size。默认为25，最多占buffer pool的25%，最大有效值可为50，超50还是</p>
<p>50</p>
<p>insert buffer 里有个bitmap用来追踪每个二级索引页的可用空间</p>
<p><img src="/images/d00e3f87236c412e53b824b7c0875898.png"></p>
<h2 id="什么时候合并insert-pool到真正的二级索引页中？"><a href="#什么时候合并insert-pool到真正的二级索引页中？" class="headerlink" title="什么时候合并insert pool到真正的二级索引页中？"></a><font style="color:#DF2A3F;">什么时候合并insert pool到真正的二级索引页中？</font></h2><pre><code>1. 当二级索引页加载时，通过bitmap发现内存存在了，这时候就会合并
2. 发现二级索引页缓冲的数据占用已经小于1/32，则会强制从磁盘里读数据然后合并数据
3. master Thead 后台线程每10秒一次
4. 数据库正常关闭
</code></pre>
<h2 id="什么时候change-buffer落盘"><a href="#什么时候change-buffer落盘" class="headerlink" title="什么时候change buffer落盘"></a><font style="color:#DF2A3F;">什么时候change buffer落盘</font></h2><pre><code>1. 数据库空闲时，后台进程落盘
2. 缓冲池不够用了
3. 数据库正常关闭时
4. redo写满了
</code></pre>
<h2 id="为什么要把change-buffer中的记录写redo"><a href="#为什么要把change-buffer中的记录写redo" class="headerlink" title="为什么要把change buffer中的记录写redo"></a><font style="color:#DF2A3F;">为什么要把change buffer中的记录写redo</font></h2><p>同样也是为了持久化么。当使用到change buffer意味着内存还没有这数据，如果这时候宕机了，数据就没了</p>
<p>这时候做redo就是为了宕机重启后可以恢复内存数据。</p>
<p>当宕机重启时：</p>
<p>先看事务是否提交，无提交直接回滚。提交了就看change buffer是否落盘，有，则直接使用change buffer</p>
<p>恢复数据；没有就通过redo 恢复changbuffer，再通过change buffer恢复数据</p>
<h2 id="可以不使用change-buffer，只使用redo记录吗"><a href="#可以不使用change-buffer，只使用redo记录吗" class="headerlink" title="可以不使用change buffer，只使用redo记录吗"></a><font style="color:#DF2A3F;">可以不使用change buffer，只使用redo记录吗</font></h2><p>PS：（虽然说redo log是顺序磁盘IO，某种情况是要比change buffer的随机内存速度快的）。<strong>change只是记</strong></p>
<p><strong>录了插入这个操作，并没有真正地插入到真正的索引页上！！！</strong></p>
<p>不行，因为change buffer里维护了insert bit map。用来快速追踪哪些页是需要合并插入缓冲的，当这些页</p>
<p>被加载到内存时，就可以被合并了。如果单靠redo log的话，当被合并的页加载到内存是无法感知的。而且</p>
<p>redo log是循环记载，会被加载到磁盘，也就是写入磁盘前必须** 合并插入缓冲区（因为redo log里有change **</p>
<p><strong>buffer的插入记录），这会加重redo log的负担</strong></p>
<blockquote>
<p><strong>Change Buffer &#x3D; 存着很多“等待插入索引页的记录”</strong><br>那么“哪些页需要合并”就是 <strong>哪些页已经有“待插入的缓存记录”但还没真正写入</strong>。<br> 合并（Merge） &#x3D; 把 Change Buffer 中某页的缓存记录，真正插入到该页中。  	</p>
</blockquote>
<h2 id="写了redo-log，为什么buffer-pool还要落盘？"><a href="#写了redo-log，为什么buffer-pool还要落盘？" class="headerlink" title="写了redo log，为什么buffer pool还要落盘？"></a><font style="color:#DF2A3F;">写了redo log，为什么buffer pool还要落盘？</font></h2><p>缓冲池大小有限，如果需要insert的页一直没被加载，insert pool会一直积累，需要落盘腾空间</p>
<p><img src="/images/d33e993a9870149ad552a359eee4ec8c.png"></p>
<h2 id="两次写？"><a href="#两次写？" class="headerlink" title="两次写？"></a><font style="color:#DF2A3F;">两次写？</font></h2><p>double write由两个部分组成，一个double buffer位于内存，2mb，另外一个位于磁盘上，buffer area上，</p>
<p>同样也是2mb</p>
<p>刷新脏页时，并不是直接把脏页数据直接刷到磁盘对应的表空间，而是先copy到double write buffer。然后</p>
<p>由double write buffer顺序写入double write area（这时候意味着这些页数据已经被持久化了）。然后再从</p>
<p>double write buffer执行fsync 将里的数据刷到各自的表空间，多了两个步骤</p>
<p>1.脏页数据被copy到了double write buffer</p>
<p>2.直接落到各自的表空间前顺序写入到了double write area里</p>
<h2 id="为什么要这么搞？"><a href="#为什么要这么搞？" class="headerlink" title="为什么要这么搞？"></a><font style="color:#DF2A3F;">为什么要这么搞？</font></h2><p>如果刷脏页，一个脏页16kb，如果写一半宕机了，就会出现磁盘的表数据人不人鬼不鬼的。 有了double </p>
<p>write area后，如果宕机重启后，<strong>会检查double write area是否有对应完整页数据，如果有的话就完整恢复</strong></p>
<p><strong>没有的话，则意味着没落盘</strong>。（其实细想的话也是一种先写日志的操作）</p>
<p>那么这种丢失能否通过redo恢复？答案是不行！因为<strong>redo是物理日志，记录要对页文件进行的物理修改</strong>，它记载了：对xx页偏移量500的位置写入aaa、将xx页偏移量650的位置的数据由bbb改为ccc。但现在的问题是，你的页是缺失或者只更改了一部分的！页已经发生了损坏，再对其重做是没有意义的</p>
<p><img src="/images/79b173dc328ae43da1ff2efceea74a94.png"></p>
<p><img src="/images/470a51fdca4f18b13d4ef9b07b351cf2.png"></p>
<h2 id="如果脏页在从内存中的doublewrite-buffer-写入到磁盘中的doublewrite-中发生了宕机怎么办？"><a href="#如果脏页在从内存中的doublewrite-buffer-写入到磁盘中的doublewrite-中发生了宕机怎么办？" class="headerlink" title="如果脏页在从内存中的doublewrite buffer 写入到磁盘中的doublewrite 中发生了宕机怎么办？ "></a><font style="color:#DF2A3F;">如果脏页在从内存中的doublewrite buffer 写入到磁盘中的doublewrite 中发生了宕机怎么办？ </font></h2><p>没有影响，这说明你还没向磁盘中刷新脏页，磁盘中的数据是完整的，宕机重启后可以根据redolog进行数据恢复 </p>
<h2 id="为什么要双写"><a href="#为什么要双写" class="headerlink" title="为什么要双写"></a><font style="color:#DF2A3F;">为什么要双写</font></h2><table>
<thead>
<tr>
<th>问题</th>
<th>Doublewrite 帮你解决什么？</th>
</tr>
</thead>
<tbody><tr>
<td>写盘时崩溃可能导致页“写了一半”</td>
<td>有 Doublewrite 做缓冲区，保证每个页要么完整写入，要么完整回滚</td>
</tr>
<tr>
<td>随机写很慢</td>
<td>先顺序写到 doublewrite area → 再随机写本体，提升整体效率</td>
</tr>
</tbody></table>
<p>两次写默认打开，可通过innodb_doublewrite关闭 </p>
<h2 id="自适应hash索引"><a href="#自适应hash索引" class="headerlink" title="自适应hash索引"></a><font style="color:#DF2A3F;">自适应hash索引</font></h2><p>InnoDB自动根据访问的频率和模式自动地为某些热点页建立哈希索引 </p>
<h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a><font style="color:#DF2A3F;">异步IO</font></h2><p>刷盘和从磁盘加载页数据都是异步IO，且会根据实际情况进行IO merge，如发现读取的页是连续的，就会连</p>
<p>续读取，而不是一页页读</p>
<h2 id="刷新邻接页："><a href="#刷新邻接页：" class="headerlink" title="刷新邻接页： "></a><font style="color:#DF2A3F;">刷新邻接页： </font></h2><p>刷新一个脏页时，会检测该页所在区的所有页，如果是脏页，一起刷新，多次IO合并为一个IO，但可能有以下问题： 是否将不怎么脏的页刷新了？该页很快又变脏了 固态硬盘有较高的IOPS，是否还需要这个特性？ 为此，InnoDB1.2.x版本开始提供参数innodb_flush_neighbors决定是否启动该功能，默认为0，不启动  </p>
<p><img src="/images/bf5cb7e27f9e3dad3d51a404ac07f9d0.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/10/14/MySQL/SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E8%AF%B4%E8%AF%B4MySql%E7%9A%84%E4%B8%80%E6%9D%A1SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/14/MySQL/SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E8%AF%B4%E8%AF%B4MySql%E7%9A%84%E4%B8%80%E6%9D%A1SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">说说MySql的一条SQL的执行过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-14 21:07:33" itemprop="dateCreated datePublished" datetime="2025-10-14T21:07:33+08:00">2025-10-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-15 08:22:31" itemprop="dateModified" datetime="2025-10-15T08:22:31+08:00">2025-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">SQL语句执行过程</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><font style="color:rgba(25, 26, 31, 0.9);">如一条简单的查询语句：</font><code>&lt;font style=&quot;color:rgba(25, 26, 31, 0.9);&quot;&gt;select * from users where age=&#39;18&#39; and name=&#39;Hollis&#39;;&lt;/font&gt;</code></p>
<p><font style="color:rgba(25, 26, 31, 0.9);">执行过程如下图：</font></p>
<p><img src="/./img/igDkakr9Q6LlsxhI/1676276921091-c44ad9b7-f173-4099-9bed-39486d5dbd07-357586.png"><img src="/images/0d4a69fcd76abbd3b5763201c7f60fd2.png"></p>
<p><font style="color:rgba(25, 26, 31, 0.9);">结合上面的说明，我们分析下这个语句的执行流程：</font></p>
<p><font style="color:rgba(25, 26, 31, 0.9);">①使用</font><strong><font style="color:rgba(25, 26, 31, 0.9);">连接器</font></strong><font style="color:rgba(25, 26, 31, 0.9);">，通过客户端&#x2F;服务器通信协议与 MySQL 建立连接。并查询是否有权限</font></p>
<p><font style="color:rgba(25, 26, 31, 0.9);">②Mysql8.0之前</font><strong><font style="color:rgba(25, 26, 31, 0.9);">检查是否开启缓存</font></strong><font style="color:rgba(25, 26, 31, 0.9);">，开启了 Query Cache 且命中完全相同的 SQL 语句，则将查询结果直接返回给客户端；</font></p>
<p><font style="color:rgba(25, 26, 31, 0.9);">③由</font><strong><font style="color:rgba(25, 26, 31, 0.9);">解析器（分析器）</font></strong><font style="color:rgba(25, 26, 31, 0.9);">进行语法分析和语义分析，并生成解析树。如查询是select、表名users、条件是age&#x3D;’18’ and name&#x3D;’Hollis’，</font><strong>预处理器</strong>则会根据 MySQL 规则进一步检查解析树是否合法。比如检查要查询的数据表或数据列是否存在等。</p>
<p><font style="color:rgba(25, 26, 31, 0.9);">④由</font><strong><font style="color:rgba(25, 26, 31, 0.9);">优化器</font></strong><font style="color:rgba(25, 26, 31, 0.9);">生成执行计划。根据索引看看是否可以优化</font></p>
<p><font style="color:rgba(25, 26, 31, 0.9);">⑤</font><strong><font style="color:rgba(25, 26, 31, 0.9);">执行器</font></strong><font style="color:rgba(25, 26, 31, 0.9);">来执行SQL语句，这里具体的执行会操作MySQL的存储引擎来执行 SQL 语句，根据存储引擎类型，得到查询结果。若开启了 Query Cache，则缓存，否则直接返回。</font></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/10/13/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%AB%E8%A1%A8%E4%BB%BB%E5%8A%A1%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%87%BA%E7%8E%B0%E6%AD%BB%E5%BE%AA%E7%8E%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/13/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%AB%E8%A1%A8%E4%BB%BB%E5%8A%A1%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%87%BA%E7%8E%B0%E6%AD%BB%E5%BE%AA%E7%8E%AF/" class="post-title-link" itemprop="url">数据库扫表任务如何避免出现死循环</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-13 22:18:42" itemprop="dateCreated datePublished" datetime="2025-10-13T22:18:42+08:00">2025-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-14 21:03:22" itemprop="dateModified" datetime="2025-10-14T21:03:22+08:00">2025-10-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><font style="color:rgb(51, 51, 51);">假如我们有一张表case_event，其中有一个字段state，它有三个值，分布是INIT、SUCCESS、以及 FAILED。</font></p>
<p><font style="color:rgb(51, 51, 51);">那么在定时任务中，我们需要把 INIT 的数据扫描出来进行执行，一般来说是这么写的 SQL：</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM case_event</span><br><span class="line">WHERE STATE = &#x27;INIT&#x27; </span><br><span class="line">ORDER BY ID </span><br><span class="line">LIMIT 200;</span><br><span class="line">//以上的数据拿出来执行 那么这时候状态就会变成 success 或者 Fail </span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">这个 SQL 看上去没啥问题，其实就是每次扫描200条记录处理。</font></p>
<p><font style="color:rgb(51, 51, 51);">但是这个SQL其实是一个典型的 bad case，因为他会出现一个致命的问题，那就是可能会导致扫描任务一直无法执行。</font></p>
<p><font style="color:rgb(51, 51, 51);">因为上述的 SQL 相当于默认了每一条记录执行之后，都能把状态推进到 SUCCESS 或者 FAILED。但是事实上并不一定的，尤其是在一些有很复杂的业务逻辑，或者一些外部调用的时候，这个地方就变成了一个分布式事务，</font><strong><font style="color:rgb(51, 51, 51);">我们没办法保证最后的 INIT-&gt;SUCCESS 或者 INIT-&gt;FAILED 一定能成功</font></strong><font style="color:rgb(51, 51, 51);">。即还是INIT</font></p>
<p><font style="color:rgb(51, 51, 51);">那如果不能成功，</font><strong><font style="color:rgb(51, 51, 51);">就会导致一部分失败的状态一直处于 INIT 状态，那么他就会每次都会被扫描起来</font></strong><font style="color:rgb(51, 51, 51);">（因为他还在前200条之内），</font><strong><font style="color:rgb(51, 51, 51);">然后还是不成功，下次还会被扫描出来</font></strong><font style="color:rgb(51, 51, 51);">。</font></p>
<p><font style="color:rgb(51, 51, 51);"></font></p>
<p><font style="color:rgb(51, 51, 51);">这样一方面会大大降低任务的效率，一直在重复执行这些不断失败的任务，另一方面，一旦失败的条数达到了200条，那么就意味着每次扫出来的数据都是这200条，导致后面的任务永远无法被执行到。</font></p>
<font style="color:rgb(51, 51, 51);">  
</font><font style="color:rgb(51, 51, 51);">这里的失败指的是没法推进状态 以及 执行失败</font>

<p><font style="color:rgb(51, 51, 51);"></font></p>
<p><font style="color:rgb(51, 51, 51);">而如果你的SQL 是这么写的，那么这个问题就更大了：</font></p>
<p><font style="color:rgb(51, 51, 51);"></font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> case_event</span><br><span class="line"><span class="keyword">WHERE</span> STATE <span class="keyword">in</span> (<span class="string">&#x27;INIT&#x27;</span> ,<span class="string">&#x27;FAILED&#x27;</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ID </span><br><span class="line">LIMIT <span class="number">200</span>;</span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">相当于你在不断的重复执行那些固定的任务，而后面的很多任务一直无法被执行。</font></p>
<p>一直在重复执行者两百条永远执行失败的任务，而后面的任务就管了一点了</p>
<p><font style="color:rgb(51, 51, 51);">如何解决这个问题呢，有一个方式，那就是增加一个游标，让你的每次查询都往后移动，如：</font></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> task <span class="keyword">where</span> status <span class="operator">=</span> <span class="string">&#x27;init&#x27;</span> <span class="keyword">and</span> id <span class="operator">&gt;</span> #&#123;id&#125;</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p><font style="color:rgb(51, 51, 51);">这里每次查询的时候，</font><strong><font style="color:rgb(51, 51, 51);">都把上一次的查询结果中的最大id 带过来</font></strong><font style="color:rgb(51, 51, 51);">，然后就可以避免再次扫描到重复的任务了，就可以让本次任务调度正常完成执行。</font></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/10/13/MySQL/MySQL%E7%9A%84varchar(50)%E5%92%8Cvarchar(500)%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/13/MySQL/MySQL%E7%9A%84varchar(50)%E5%92%8Cvarchar(500)%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">MySQL的varchar(50)和varchar(500)区别?</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-13 00:06:23" itemprop="dateCreated datePublished" datetime="2025-10-13T00:06:23+08:00">2025-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-15 09:37:14" itemprop="dateModified" datetime="2025-10-15T09:37:14+08:00">2025-10-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7350228838151847976">https://juejin.cn/post/7350228838151847976</a></p>
<p>这个的话，如果说是磁盘占用其实都是一样的，比如说你一个字段为20，那么磁盘所占用的一定是20</p>
<p>但如果从内存占用来说，这两个就有比较大的区别的了。你把这个字段读到内存时，为这个字段申请的内存是根据varchar（xx）这东西来确定的，因为我们操作系统本身为数据申请内存，都有预申请的一个过程，一次申请多少呢。</p>
<p><strong><font style="color:rgb(0, 0, 0);">总结的核心结论：</font></strong></p>
<ul>
<li><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;VARCHAR&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">的“可变长度”特性主要体现在</font><strong><font style="color:rgb(0, 0, 0);">磁盘存储</font></strong><font style="color:rgb(0, 0, 0);">上，使其能节省空间。</font></li>
<li><font style="color:rgb(0, 0, 0);">在</font><strong><font style="color:rgb(0, 0, 0);">内存</font></strong><font style="color:rgb(0, 0, 0);">中，为了性能和简化数据读取流程，MySQL 会为</font><font style="color:rgb(0, 0, 0);"> </font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;VARCHAR&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">列</font><strong><font style="color:rgb(0, 0, 0);">预先分配其定义的最大长度 (</font></strong><code>**&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;N&lt;/font&gt;**</code><strong><font style="color:rgb(0, 0, 0);">) 所需的空间</font></strong><font style="color:rgb(0, 0, 0);">。</font></li>
<li><font style="color:rgb(0, 0, 0);">这种内存分配机制意味着</font><strong><font style="color:rgb(0, 0, 0);">过度定义</font>****<font style="color:rgb(0, 0, 0);"> </font></strong><code>**&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;VARCHAR&lt;/font&gt;**</code><strong><font style="color:rgb(0, 0, 0);">的最大长度 (</font></strong><code>**&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;N&lt;/font&gt;**</code><strong><font style="color:rgb(0, 0, 0);">) 会直接导致内存浪费</font></strong><font style="color:rgb(0, 0, 0);">，这种浪费是普遍存在的（不仅限于排序操作）。</font></li>
<li><font style="color:rgb(0, 0, 0);">因此，在定义 </font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;VARCHAR&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">字段时，</font><strong><font style="color:rgb(0, 0, 0);">务必根据实际业务需求，选择一个足够用但又不会过度冗余的最大长度 (</font></strong><code>**&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;N&lt;/font&gt;**</code><strong><font style="color:rgb(0, 0, 0);">)</font></strong><font style="color:rgb(0, 0, 0);">，以平衡磁盘空间节省和内存使用效率。</font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;VARCHAR(255)&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">的流行与其在单字节长度前缀下的存储效率优化有关。</font></li>
</ul>
<p><img src="/images/fd3666d17ac1bd6be81f1249496ba855.png"></p>
<ol>
<li><strong><font style="color:rgb(0, 0, 0);">磁盘存储（节省空间）：</font></strong><ul>
<li><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;VARCHAR&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">在磁盘上存储的是</font><strong><font style="color:rgb(0, 0, 0);">实际数据</font></strong><font style="color:rgb(0, 0, 0);"> + </font><strong><font style="color:rgb(0, 0, 0);">一个或两个字节的长度前缀</font></strong><font style="color:rgb(0, 0, 0);">。</font></li>
<li><font style="color:rgb(0, 0, 0);">长度前缀指示了该字段值实际占用的字节数。</font></li>
<li><font style="color:rgb(0, 0, 0);">因此，磁盘空间占用是</font><strong><font style="color:rgb(0, 0, 0);">可变的</font></strong><font style="color:rgb(0, 0, 0);">，只取决于实际存储的数据长度（加上很小的长度前缀开销）。定义的最大长度 (</font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;VARCHAR(N)&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">) 只限制了能存储多少数据，不影响实际存储空间（除非数据达到最大长度）。</font></li>
</ul>
</li>
<li><strong><font style="color:rgb(0, 0, 0);">内存分配（固定大小）：</font></strong><ul>
<li><font style="color:rgb(0, 0, 0);">当 MySQL 从磁盘读取一行数据到内存时，它需要</font><strong><font style="color:rgb(0, 0, 0);">预先为每一列分配内存空间</font></strong><font style="color:rgb(0, 0, 0);">。</font></li>
<li><font style="color:rgb(0, 0, 0);">在读取具体数据内容</font><strong><font style="color:rgb(0, 0, 0);">之前</font></strong><font style="color:rgb(0, 0, 0);">，MySQL 只知道该列的定义：它是一个</font><font style="color:rgb(0, 0, 0);"> </font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;VARCHAR&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">，并且其</font><strong><font style="color:rgb(0, 0, 0);">最大允许长度是</font>****<font style="color:rgb(0, 0, 0);"> </font></strong><code>**&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;N&lt;/font&gt;**</code><strong><font style="color:rgb(0, 0, 0);">字节</font></strong><font style="color:rgb(0, 0, 0);">。</font></li>
<li><font style="color:rgb(0, 0, 0);">MySQL </font><strong><font style="color:rgb(0, 0, 0);">无法</font></strong><font style="color:rgb(0, 0, 0);">在读取数据之前知道该字段在这一行中的</font><strong><font style="color:rgb(0, 0, 0);">实际长度</font></strong><font style="color:rgb(0, 0, 0);">是多少（是 10 还是 20？）。这个实际长度信息是</font><strong><font style="color:rgb(0, 0, 0);">存储在数据本身的开头</font></strong><font style="color:rgb(0, 0, 0);">（长度前缀）。</font></li>
<li><font style="color:rgb(0, 0, 0);">为了能够安全地接收从磁盘读取出来的整行数据（包括所有列），MySQL 必须为每个</font><font style="color:rgb(0, 0, 0);"> </font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;VARCHAR&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">列分配</font><strong><font style="color:rgb(0, 0, 0);">足够容纳其最大可能长度 (</font></strong><code>**&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;N&lt;/font&gt;**</code><strong><font style="color:rgb(0, 0, 0);">) 的内存空间</font></strong><font style="color:rgb(0, 0, 0);">。</font></li>
<li><strong><font style="color:rgb(0, 0, 0);">关键原因：性能。</font></strong><font style="color:rgb(0, 0, 0);"> 如果每次读取一行时，都尝试先读取长度前缀，再根据这个长度精确申请内存，然后再读取实际数据，会导致大量的、细碎的内存分配操作和额外的 I&#x2F;O 定位。这会</font><strong><font style="color:rgb(0, 0, 0);">极大地降低数据读取的性能</font></strong><font style="color:rgb(0, 0, 0);">。预先按最大长度分配内存虽然可能浪费一些空间，但</font><strong><font style="color:rgb(0, 0, 0);">避免了频繁的内存申请开销</font></strong><font style="color:rgb(0, 0, 0);">，是性能与内存利用之间的权衡。</font></li>
</ul>
</li>
<li><strong><font style="color:rgb(0, 0, 0);">定义长度 (</font></strong><code>**&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;N&lt;/font&gt;**</code><strong><font style="color:rgb(0, 0, 0);">) 的重要性：</font></strong><ul>
<li><font style="color:rgb(0, 0, 0);">正因为内存分配是按定义的最大长度 (</font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;N&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">) 进行的，所以</font><font style="color:rgb(0, 0, 0);"> </font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;VARCHAR(N)&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">中的</font><font style="color:rgb(0, 0, 0);"> </font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;N&lt;/font&gt;</code><strong><font style="color:rgb(0, 0, 0);">直接影响内存消耗</font></strong><font style="color:rgb(0, 0, 0);">。</font></li>
<li><font style="color:rgb(0, 0, 0);">即使你存储的实际数据很短（比如</font><font style="color:rgb(0, 0, 0);"> </font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;VARCHAR(255)&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">只存了 10 个字符），MySQL 在内存中也会为该字段预留 255 字节（或根据字符集计算出的最大字节数）的空间。</font></li>
<li><strong><font style="color:rgb(0, 0, 0);">过度定义</font>****<font style="color:rgb(0, 0, 0);"> </font></strong><code>**&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;N&lt;/font&gt;**</code><strong><font style="color:rgb(0, 0, 0);">(如</font>****<font style="color:rgb(0, 0, 0);"> </font></strong><code>**&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;VARCHAR(1000)&lt;/font&gt;**</code><strong><font style="color:rgb(0, 0, 0);">但实际只用 10 字节) 会导致严重的内存浪费。</font></strong><font style="color:rgb(0, 0, 0);"> 这种浪费不仅发生在排序等需要临时表的操作中（如原文所述），也发生在</font><strong><font style="color:rgb(0, 0, 0);">任何将行数据读入内存</font></strong><font style="color:rgb(0, 0, 0);">的操作中（如简单的</font><font style="color:rgb(0, 0, 0);"> </font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;SELECT&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">查询、连接操作、在内存中更新数据等）。这就是为什么强调“即使不排序，也可能有其它内存不够的问题出现”。</font></li>
</ul>
</li>
<li><strong><font style="color:rgb(0, 0, 0);">255 字节的特殊性：</font></strong><ul>
<li><font style="color:rgb(0, 0, 0);">长度前缀需要占用空间。对于最大长度</font><font style="color:rgb(0, 0, 0);"> </font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;N&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">&lt;&#x3D; 255 字节的</font><font style="color:rgb(0, 0, 0);"> </font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;VARCHAR&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">，长度前缀只需要 </font><strong><font style="color:rgb(0, 0, 0);">1 个字节</font></strong><font style="color:rgb(0, 0, 0);">。</font></li>
<li><font style="color:rgb(0, 0, 0);">对于最大长度</font><font style="color:rgb(0, 0, 0);"> </font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;N&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">&gt; 255 字节的</font><font style="color:rgb(0, 0, 0);"> </font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;VARCHAR&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">，长度前缀需要 </font><strong><font style="color:rgb(0, 0, 0);">2 个字节</font></strong><font style="color:rgb(0, 0, 0);">。</font></li>
<li><font style="color:rgb(0, 0, 0);">因此，</font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;VARCHAR(255)&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">是一个非常常见的定义：</font><ul>
<li><font style="color:rgb(0, 0, 0);">它充分利用了单字节长度前缀能表示的最大长度（255）。</font></li>
<li><font style="color:rgb(0, 0, 0);">定义</font><font style="color:rgb(0, 0, 0);"> </font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;VARCHAR(256)&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">会导致长度前缀变成 2 字节，而实际能存储的数据只比</font><font style="color:rgb(0, 0, 0);"> </font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;VARCHAR(255)&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">多 1 字节（256 vs 255），但长度前缀开销翻倍（2字节 vs 1字节）。从存储效率角度看，</font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;VARCHAR(255)&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">是单字节长度前缀下的最优选择。</font></li>
<li><strong><font style="color:rgb(0, 0, 0);">注意：</font></strong><font style="color:rgb(0, 0, 0);"> 这里的 255&#x2F;256 指的是</font><strong><font style="color:rgb(0, 0, 0);">字节数</font></strong><font style="color:rgb(0, 0, 0);">，不是字符数。对于多字节字符集（如 UTF8MB4），一个字符可能占用多个字节，</font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;VARCHAR(255)&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">能存储的字符数会少于 255。</font></li>
</ul>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://www.soyorin.online/2025/10/11/%E5%9C%BA%E6%99%AF%E9%A2%98/%E5%BC%80%E6%94%BE%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%87%8F%E7%BA%A7%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/boqi.jpg">
      <meta itemprop="name" content="lkl">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | soyo的跨机房部署、同城双活、异地多活、9个9高可用博客yuque笔记同步site">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/11/%E5%9C%BA%E6%99%AF%E9%A2%98/%E5%BC%80%E6%94%BE%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%87%8F%E7%BA%A7%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">开放式数据量级问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-11 01:40:20" itemprop="dateCreated datePublished" datetime="2025-10-11T01:40:20+08:00">2025-10-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-17 23:41:25" itemprop="dateModified" datetime="2025-10-17T23:41:25+08:00">2025-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%9C%BA%E6%99%AF%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">场景题</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="TOPK"><a href="#TOPK" class="headerlink" title="TOPK"></a>TOPK</h2><p><img src="/images/9d687c68cef84c2e14746150461ca941.png"></p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>维护一个 n &#x3D; k 的堆 PriorityQueue，for i &lt; 数据量级来元素就加进去，如果超过了 k，就poll 堆顶元素</p>
<p><img src="/images/ce7391d901d606e646b62fcafa4a0038.png"></p>
<p>时间复杂度就是 数据量级 log K</p>
<p>空间复杂度，因为堆本质其实就是一数组，空间为 O k</p>
<h3 id="类似快排法"><a href="#类似快排法" class="headerlink" title="类似快排法"></a>类似快排法</h3><h3 id="使用hash"><a href="#使用hash" class="headerlink" title="使用hash"></a>使用hash</h3><p>对于这种问题 </p>
<p><img src="/images/ad19b3809e6c5a0f3f835fffb77530af.png"></p>
<h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><h3 id="混合查询"><a href="#混合查询" class="headerlink" title="混合查询"></a>混合查询</h3><p><img src="/images/d4cdb8cf5d13043e31597371d4c50cac.png"></p>
<h2 id="有一批文件，每个文件里面有很多单词，如何快速统计所有单词的出现次数"><a href="#有一批文件，每个文件里面有很多单词，如何快速统计所有单词的出现次数" class="headerlink" title="有一批文件，每个文件里面有很多单词，如何快速统计所有单词的出现次数?"></a>有一批文件，每个文件里面有很多单词，如何快速统计所有单词的出现次数?</h2><h2 id="数据重复、是否存在问题"><a href="#数据重复、是否存在问题" class="headerlink" title="数据重复、是否存在问题"></a>数据重复、是否存在问题</h2><h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>bitmap 其实就是对HashSet或者数组的一个压缩版</p>
<p>Java的BItSet</p>
<p>海量数据的极致优化还有 压缩位图</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>解决 return true 就表示 可能在 和 return false 就表示 一定不在的</p>
<p>解决的业务问题：</p>
<p><img src="/images/2c798d43ab0960586e7be62b2db80811.png"></p>
<h2 id="找出排名前500的数"><a href="#找出排名前500的数" class="headerlink" title="找出排名前500的数"></a>找出排名前500的数</h2><p><img src="/images/c038fb47e1e8521cedadf350040a5d28.png"></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>思路</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>优劣</th>
</tr>
</thead>
<tbody><tr>
<td>方法1：逐个归并（维护 top500）</td>
<td>先取第一个数组的后500个，然后与后续数组逐个合并，再保留最大500个</td>
<td>每次合并 500 + 500 → O(500)，共 10000 次 → <strong>O(10000 × 500) &#x3D; 5×10⁶ ≈ 5M</strong></td>
<td>O(500)</td>
<td>简单稳定</td>
</tr>
<tr>
<td>方法2：多路堆（K 路最大堆）</td>
<td>每个数组取最后一个元素（最大值）放入大顶堆，每次弹出一个并往回移动指针</td>
<td>每次堆操作 log10000，执行500次 → <strong>O(500 × log10000) ≈ 500 × 14 &#x3D; 7000</strong>，外加初始化堆 10000 → 10000log10000≈ 140000 → 总约 15 万</td>
<td>O(10000 + 500)</td>
<td><strong>性能最优</strong></td>
</tr>
</tbody></table>
<p><img src="/images/568bc6bef8779b99769eec2693a622ea.png"></p>
<p>堆本质上就是一颗完全二叉树</p>
<p>多路堆，最优解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Top500FromSortedArrays</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> value;      <span class="comment">// 元素值</span></span><br><span class="line">        <span class="type">int</span> row;        <span class="comment">// 来自哪个数组</span></span><br><span class="line">        <span class="type">int</span> index;      <span class="comment">// 在该数组中的下标（倒序移动）</span></span><br><span class="line">        </span><br><span class="line">        Node(<span class="type">int</span> value, <span class="type">int</span> row, <span class="type">int</span> index) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.row = row;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">top500</span><span class="params">(<span class="type">int</span>[][] arrs)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> arrs.length;  <span class="comment">// 数组个数 (10000)</span></span><br><span class="line">        PriorityQueue&lt;Node&gt; maxHeap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">                (a, b) -&gt; b.value - a.value   <span class="comment">// 大顶堆</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化：每个数组的最后一个元素入堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> arrs[i].length - <span class="number">1</span>;</span><br><span class="line">            maxHeap.offer(<span class="keyword">new</span> <span class="title class_">Node</span>(arrs[i][lastIndex], i, lastIndex));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 存前500</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; count &lt; <span class="number">500</span> &amp;&amp; !maxHeap.isEmpty(); count++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">top</span> <span class="operator">=</span> maxHeap.poll();</span><br><span class="line">            result.add(top.value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 往前移动一个位置，继续加入该数组的下一个大值</span></span><br><span class="line">            <span class="keyword">if</span> (top.index - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                maxHeap.offer(<span class="keyword">new</span> <span class="title class_">Node</span>(arrs[top.row][top.index - <span class="number">1</span>], top.row, top.index - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造一个简单的测试用例 (真实情况是10000×500，这里只演示)</span></span><br><span class="line">        <span class="type">int</span>[][] data = &#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;,</span><br><span class="line">                &#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(top500(data));  <span class="comment">// 输出最大的前5个</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="两个大文件中找出共同URL"><a href="#两个大文件中找出共同URL" class="headerlink" title="两个大文件中找出共同URL"></a>两个大文件中找出共同URL</h2><p><img src="/images/f3965b351a9ce71b7b6a09e69fd2d9e2.png"></p>
<p>64 byte * 50 亿 ，一个文件 320g 全加载到内存 建立Hash表，那肯定是不现实的。</p>
<p>还是 分治</p>
<p>对A ：hash(url) % 1000 -&gt; 1000个小文件 命名为 a0,a1,a2….. a999</p>
<p> 对B：同样，hash一定得相同</p>
<p>那么a99 和 b99里面可能存在相同的。但a99和a98里面的就不可能出现相同的</p>
<p>然后再把小文件加载到内存，建立hashmap</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/45/">45</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2019 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">lkl</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/soyobat" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
